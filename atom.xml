<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hurrican</title>
  <icon>https://www.gravatar.com/avatar/aa3c406e9be772646e8349e7f61092c9</icon>
  <subtitle>走自己的路，让别人去说</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://focusok.xyz/"/>
  <updated>2018-03-13T15:09:00.541Z</updated>
  <id>http://focusok.xyz/</id>
  
  <author>
    <name>hurricane</name>
    <email>hurricanhup@sina.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python学习</title>
    <link href="http://focusok.xyz/2018/01/21/python%E5%AD%A6%E4%B9%A0/"/>
    <id>http://focusok.xyz/2018/01/21/python学习/</id>
    <published>2018-01-21T15:17:40.000Z</published>
    <updated>2018-03-13T15:09:00.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数和浮点、复数"><a href="#整数和浮点、复数" class="headerlink" title="整数和浮点、复数"></a>整数和浮点、复数</h3><p>　　Python可以处理任意大的整数和浮点数，整数为int类型，浮点数为float类型。整数和浮点数均能够通过＋、－、*、/进行加减乘除运算。<a id="more"></a>    </p><pre><code>&gt;&gt;&gt;2+2   4    &gt;&gt;&gt;&gt;5/2  2.5  &gt;&gt;&gt;5*1.8  9.0</code></pre><p>　　一般除法运算/得到的数据类型默认为浮点数类型，如果想得到商的整数部分，使用//,想得到余数使用%。  </p><pre><code>&gt;&gt;&gt;5//2  2  &gt;&gt;&gt;5%2  1</code></pre><p> 　　在Python中，**相当于幂运算。  </p><pre><code>&gt;&gt;&gt;3**3  27&gt;&gt;&gt;(-3)**29</code></pre><p>　　Python还内置了复数的定义和运算，’j’或J表示虚部，复数一般表示为a+bj。  </p><pre><code>&gt;&gt;&gt;(3+2j)/(1+5j)  (0.5-0.5j)&gt;&gt;&gt;(1+3j)*(2+2j)  (-4+8j)</code></pre><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>　　除了数字Python还能操作字符串。字符串可以使用单引号’…’或者双引号”…”的方式表示，若引号内有引号为字符串的内容，使用\排除歧义。  </p><pre><code>&gt;&gt;&gt;&apos;hello world&apos;  &apos;hello world&apos;&gt;&gt;&gt;&apos;Lilei\&apos;s hat&apos;&quot;Lilei&apos;s hat&quot;&gt;&gt;&gt;&apos;Lilei say:&quot;how are you？&quot;&apos;&apos;Lilei say:&quot;how are you？&quot;&apos;&gt;&gt;&gt;&quot;\&quot;yes,\&quot;he said&quot;&apos;&quot;yes,&quot;he said&apos;  &gt;&gt;&gt;&apos;&quot;yes,you are good,&quot;he said.&apos;&apos;&quot;yes,you are good,&quot;he said.&apos; #单引号中的双引号不产生歧义  &gt;&gt;&gt;&quot;isn&apos;t he?&quot;  &quot;isn&apos;t he?&quot;  #双引号中的单引号也不产生歧义  </code></pre><p>　　如果不想将\解释为转义字符，只需要在引用号前加r，表示原生（raw）保留。  </p><pre><code>&gt;&gt;&gt;print(&apos;C:\X\name&apos;)  #\n为换行字符C:\X  ame  &gt;&gt;&gt;print(r&apos;C:\X\name&apos;)  C:\X\name  </code></pre><p>　　字符串还可以使用+进行合并操作，使用*作为重复操作。（没有-和/的运算）  </p><pre><code>&gt;&gt;&gt;3*&apos;im&apos;&apos;imimim&apos;&gt;&gt;&gt;3*&apos;im&apos;+&apos;k&apos;  &apos;imimimk&apos;   </code></pre><p>　　<br>  　字符串可以根据下标读取内容，第一个字符下标为０.但下标所取超出实际下标范围将会报错。　　</p><pre><code>&gt;&gt;&gt;word=&apos;python&apos;  &gt;&gt;&gt;word[0]  &apos;p&apos;  &gt;&gt;&gt;word[5]&apos;n&apos;&gt;&gt;&gt;word[-1] #最后一个字符&apos;n&apos;&gt;&gt;&gt;word[-2] #倒数第二个字符&apos;o&apos;&gt;&gt;&gt;word[20]...IndexError:string index out of range</code></pre><p>　　    字符串还可以进行切片运算进行部分字符的选取。切片运算a[x:y:z],表示字符串a中从下标x开始步进为z取字符，取到下标为y截止所组成的字符串。但切片运算下标超出范围时，将不会报故障。  </p><pre><code>&gt;&gt;&gt;word=&apos;abcdefghijklmn&apos;&gt;&gt;&gt;word[1:4] #默认为word[1:4:1]&apos;bcd&apos;&gt;&gt;&gt;word[1:8:2]&apos;bdfh&apos;&gt;&gt;&gt;word[-8:8:2]&apos;fh&apos; &gt;&gt;&gt;word[18:20] &apos; &apos;           #返回空  </code></pre><p>　　字符串不允许使用下标对单个或部分字符直接赋值来改变字符串。  </p><pre><code>&gt;&gt;&gt;word[0]=&apos;k&apos;...TypeError: &apos;str&apos; object does not support item assignment&gt;&gt;&gt;word[1:]=&apos;bcdefghijklmn&apos;...TypeError: &apos;str&apos; object does not support item assignment  </code></pre><p>　   内置函数len()返回字符串的长度。  </p><pre><code>&gt;&gt;&gt;len(&apos;abcde&apos;)5 &gt;&gt;&gt;len(&apos;你好！&apos;)3  </code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>　　Python中内置很多聚合型数据类型将不同的值聚合在一起。其中最重要最常见的莫过于列表了。列表使用一对方括号将不同数据组合在一起，这些组合的数据可以是不同的数据格式。  </p><pre><code>&gt;&gt;&gt;s=[1,2,3]&gt;&gt;&gt;s[1,2,3]&gt;&gt;&gt;a=[1,&apos;b&apos;]&gt;&gt;&gt;a[1,&apos;b&apos;]</code></pre><p>　　和字符串一样（任何其他内置的序列类型数据），列表也可以进行切片操作。  </p><pre><code>&gt;&gt;&gt;s[1:-1][2]&gt;&gt;&gt;s[1:][2,3]  </code></pre><p>　　列表也可以使用“+”操作符，进行连接操作。</p><pre><code>&gt;&gt;&gt;s+[3,4,5,6,7][1,2,3,3,4,5,6,7]  </code></pre><p>　　但列表不同于字符串的是列表是可以更改的，列表可以直接通过下标进行赋值。</p><pre><code>&gt;&gt;&gt;cube=[1,8,27,67,125]&gt;&gt;&gt;cube[1,8,27,67,125]&gt;&gt;&gt;cube[3]=64&gt;&gt;&gt;cube[1,8,27,64,125]&gt;&gt;&gt;cube[0:3]=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]&gt;&gt;&gt;cube[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,64,125]  &gt;&gt;&gt;cube[0:3]=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]&gt;&gt;&gt;cube[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,64,125]  </code></pre><p>　　　可以使用append()函数在列表后面添加元素。</p><pre><code>&gt;&gt;&gt;cube.append(6**3)&gt;&gt;&gt;cube[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,64,125,216]  </code></pre><p>　　　同样len（）函数也可以返回列表的长度（元素个数）。</p><pre><code>&gt;&gt;&gt;len([1,2],3)  #列表的元素可以是列表2  </code></pre><h2 id="通往Python编程的第一步"><a href="#通往Python编程的第一步" class="headerlink" title="通往Python编程的第一步"></a>通往Python编程的第一步</h2><p>　　当然，使用Python可以完成比计算更复杂的任务。比如，可以使用Python写出Fibonacci数列：  </p><pre><code>&gt;&gt;&gt;#Fibonacci series:...a,b=0,1&gt;&gt;&gt;while b&lt;10:...     print(b)...     a,b=b,a+b...12358</code></pre><p>　　<br>　　上述代码中第一行以#开头为注释，无其他作用，仅是说明下面代码完成的功能是打印Fibonacci数列，第2行定义两变量并赋初值为0、1，接下来是一个While循环，在循环的条件b&lt;10的情况下进行打印b值和累加。不同于C或C++语言，整个代码结构层次不使用；和{}进行区别，而是使用缩进量，两行代码缩进相同，表示进行的操作在同一个层级。</p><h2 id="流控制语句"><a href="#流控制语句" class="headerlink" title="流控制语句"></a>流控制语句</h2><p>　　除了while循环语句，和其他语言一样，Python还有很多其他流控制语句。  </p><h3 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h3><p>　　最常用的语句莫过于if条件语句，如下例：  </p><pre><code>&gt;&gt;&gt;a=int(input(&quot;Please enter an integer:&quot;))Please enter an integer:25&gt;&gt;&gt;if x&lt;0:          x=0        print(&apos;Negative changed to 0&apos;)    elif x==0:        print(&apos;0&apos;)    elif x==1:        print(&apos;Single&apos;)    else:        print(&apos;More&apos;)  ...  More</code></pre><h3 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h3><p>　　for循环语句可能在Python中和C语言中稍微有点不一样。C语言中for循环语句一般给出循环的起始值、步进和结束值，Python中for语句按照特定的序列进行循环。例如：</p><pre><code>&gt;&gt;&gt;words=[&apos;cat&apos;,&apos;window&apos;,&apos;difference&apos;]&gt;&gt;&gt;for i in words:        print(i,len(i))...cat 3window 6difference 10</code></pre><p>　　如果需要根据循环的条件序列改变序列本身，最好先将序列的复制作为循环条件：</p><pre><code>&gt;&gt;&gt;for i in words[:]:  #该切片操作相当于words的复制，如果此处直接是 i in words，程序将会导致编译器死循环。        if len(i)&gt;6:            words.insert(0,i)...&gt;&gt;&gt;words[&apos;difference&apos;,&apos;cat&apos;,&apos;window&apos;,&apos;difference&apos;]</code></pre><h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h3><p>　　使用内置函数range()可以构建序列。</p><pre><code>&gt;&gt;&gt;for i in range(3):        print(i)...012&gt;&gt;&gt;list(range(5,10))[5,6,7,8,9]&gt;&gt;&gt;list(range(0,10,3))[0,3,6,9]</code></pre><p>　　　　结合range()和len()，可以产生C语言中for语句的效果。  </p><pre><code>&gt;&gt;&gt;a=[&apos;Peter&apos;,&apos;is&apos;,&apos;a&apos;,&apos;boy&apos;]&gt;&gt;&gt;for i in range(len(a)):        print(i,a[i])...0 Peter1 is 2 a  3 boy</code></pre><h3 id="break和continue以及循环中的else语句"><a href="#break和continue以及循环中的else语句" class="headerlink" title="break和continue以及循环中的else语句"></a>break和continue以及循环中的else语句</h3><p>　　同C语言中一样，break语句也是跳出最接近break一层的for或者while循环。<br>　　循环中也可以有else语句；当for循环终止或while循环判断条件为false时，跟在后面的else语句会运行一次，但如果有break语句提前终止循环，else语句将不会运行。  </p><pre><code>&gt;&gt;&gt;prime=[]&gt;&gt;&gt;for n in range(2,10):           for x in prime:            if n%x==0:            print(n,&apos;equals&apos;,x,&apos;*&apos;,n//x)            break            else:        #此处else语句不与if为一层，而是与for循环为一对            prime.append(n)            print(n,&apos;is a prime&apos;)    2 is a prime        #for x  in prime:循环运行终止，未遇到break跳出循环，else语句运行一次。    3 is a prime    4 equals 2 * 2      #break跳出循环，else语句未运行    5 is a prime    6 equals 2 * 3    7 is a prime    8 equals 2 * 4    9 equals 3 * 3</code></pre><p>　　continue语句也是从C语言中借鉴过来的，也是跳过当次循环中continue之后的操作。</p><pre><code>&gt;&gt;&gt;for num in range(2,5):        if num%2==0:            print(&quot;found an even number&quot;,num)            continue        print(&quot;Found a odd num&quot;,num)    found an even number 2    found an odd num 3    found an even number 4</code></pre><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>　　我们举一个打印任意范围内的Fibonacci数列的例子来说明如何定义函数：  </p><pre><code>&gt;&gt;&gt;def fib(n):          #函数实现打印n以内的Fibonacci数列        a,b=0,1        while a&lt;n:            print(a,end=&quot; &quot;)            a,b=b,a+b        print()&gt;&gt;&gt;fib(200)0 1 1 2 3 5 8 13 21 34 55 89 144   </code></pre><p>　　如上述例子，函数的定义以def作为关键字，后面紧跟着函数名称（例子中fib），括号内为函数参数列表，函数主体另起一行开始，且和关键字要有缩进。函数第一行一般会以#添加注释，以说明函数的功能或其他信息，添加注释是个很好的习惯，有很多工具可以根据这些注释自动生成说明文档，也使别人浏览代码时更简单易懂。<br>　　函数的执行会引进一个新的本地符号列表用以存储函数的局部变量。更确切的说，函数中所有变量的配置值存储在本地符号列表里；但是变量的引用会先在本地符号列表中查找，如果本地列表中没有，然后在封闭函数的本地变量列表中查找，接着是全局符号列表，最后还没找到，才会访问内置名称表中进行查找。因此全局变量不能在函数内部直接赋值（除非对变量进行了全局声明），虽然全局变量也可以被引用。<br>　　调用函数时，在函数的本地符号列表中引入函数调用的实际参数；因此，参数使用按特定值调用（这个特定值始终是调用对象的引用，而不是调用对象的值）。当一个函数调用另一个函数时，就会为该调用新建一个本地符号列表。<br>　　函数定义在当前符号表中引入函数名。函数名的值有一个被解释器作为用户定义函数识别的类型。该值可以分配给另一个名称，该名称也可以用作函数。这就是Python中重命名机制：  </p><pre><code>&gt;&gt;&gt;fib&lt;function fib at 0x0000000001D13E18&gt;&gt;&gt;&gt;f=fib&gt;&gt;&gt;f(20)0 1 1 2 3 5 8 13</code></pre><p>　　<br>　　上述函数并不返回值，也许你会因此而认为它不应该是一个函数而应该只是个执行过程。但实际上，及时函数没有return返回声明但还是会返回一个值；这个值被称为None（它是一个内置名）。如果None是函数唯一的返回值时，解释器一般会忽略这个返回值。如果想看到这个返回值，可以使用print():  </p><pre><code>&gt;&gt;&gt;fib(0)&gt;&gt;&gt;print(fib(0))None&gt;&gt;&gt;print(fib(20))0 1 1 2 3 5 8 13None</code></pre><p>　　要想返回Fibonacci序列很简单：</p><pre><code>&gt;&gt;&gt;def fib2(n):  #返回n以内的Fibonacci序列        result=[]        a,b=0,1        while a&lt;n:            result.append(a)   #在list最后插入a            a,b=b,a+b        return result&gt;&gt;&gt;s=fib2(20)&gt;&gt;&gt;s[0,1,1,2,3,5,8,13]</code></pre><h3 id="定义默认参数值"><a href="#定义默认参数值" class="headerlink" title="定义默认参数值"></a>定义默认参数值</h3><p>　　给函数定义默认的参数值能够使用函数时更灵活地调用参数。比如：</p><pre><code>def ask_ok(pro,retries=4,reminder=&apos;please try again!&apos;):    while True:        ok=input(pro)        if ok in (&apos;y&apos;,&apos;ye&apos;,&apos;yes&apos;):            return True        if ok in (&apos;n&apos;,&apos;no&apos;,&apos;nop&apos;,&apos;nope&apos;):            return False        retries=retries-1        if retries&lt;0:            raise ValueError(&apos;invalid user response&apos;)        print(reminder)</code></pre><p>　　<br>  上面的定义的ask_ok函数后两个参数给定了默认值，因此下面三种方法都可以调用此函数。  </p><pre><code>ask_ok(&apos;Do you want to quit?&apos;) ask_ok(&apos;Ok to overwrite the file?&apos;,2)　　ask_ok(&apos;Ok to overwrite the file?&apos;,2,&apos;Go ahead,only &quot;yes&quot; or &quot;no&quot;&apos;)  </code></pre><p>　　　但是给定默认的初值的参数一定要在未给定默认值参数之后，否则当调用参数缺省时，编译器将会报故。</p><pre><code>&gt;&gt;&gt;def ask_ok( retries=4, reminder=&apos;Please try again!&apos;,prompt):     while True:         ok = prompt           if ok in (&apos;y&apos;, &apos;ye&apos;, &apos;yes&apos;):                return True        if ok in (&apos;n&apos;, &apos;no&apos;, &apos;nop&apos;, &apos;nope&apos;):                return False        retries = retries - 1        if retries &lt; 0:             raise ValueError(&apos;invalid user response&apos;)        print(reminder)  &gt;&gt;&gt;ask_ok(&apos;y&apos;) ....SyntaxError: non-default argument follows default argument</code></pre><p>　　默认的参数值会在函数被定义的时刻就被赋值，因此：</p><pre><code>i=5def f(arg=i):    print(arg)i=6f()5           #函数在定义时，参数被赋值为5</code></pre><p>　　<br>　　默认的参数值只会被赋值一次。当默认参数值为像list、字典（dictionary）或大多数类实例的可变对象时。例如，下面的函数在后续调用中累积传递给它的参数：</p><pre><code>def f(a,L=[]):    L.append(a)    return Lprint(f(1))print(f(2))print(f(3))</code></pre><p>　　结果将会打印出  </p><pre><code>[1][1, 2][1, 2, 3]</code></pre><p>　　如果不想在以后的调用中共享默认值，你可以像这样编写函数：</p><pre><code>def f(a,L=None):    if L is None:        L=[]    L.append(a)    return L  </code></pre><h3 id="关键字参数调用"><a href="#关键字参数调用" class="headerlink" title="关键字参数调用"></a>关键字参数调用</h3><p>　　函数还可以使用kwarg=value形式的关键字进行参数调用。比如下面函数：　　</p><pre><code>def parrot(voltage, state=&apos;a stiff&apos;, action=&apos;voom&apos;, type=&apos;Norwegian Blue&apos;):    print(&quot;-- This parrot wouldn&apos;t&quot;, action, end=&apos; &apos;)    print(&quot;if you put&quot;, voltage, &quot;volts through it.&quot;)    print(&quot;-- Lovely plumage, the&quot;, type)    print(&quot;-- It&apos;s&quot;, state, &quot;!&quot;)　　</code></pre><p>　　函数接收一个必要参数和三个可选参数。参数的调用可以使用下面任意方式：</p><pre><code>parrot(1000)                                         parrot(voltage=1000)                                 parrot(voltage=1000000, action=&apos;VOOOOOM&apos;)            parrot(action=&apos;VOOOOOM&apos;, voltage=1000000)             parrot(&apos;a million&apos;, &apos;bereft of life&apos;, &apos;jump&apos;)        parrot(&apos;a thousand&apos;, state=&apos;pushing up the daisies&apos;)  </code></pre><p>　　但是像下面的调用方式，编译器将会报错：</p><pre><code>parrot()                     # 缺少不可缺省参数parrot(voltage=5.0, &apos;dead&apos;)  # 不允许非关键字参数在关键字参数之后 parrot(110, voltage=220)     # 给一个参数重复提供初值parrot(actor=&apos;John Cleese&apos;)  # 不可知的参数（未定义的参数）  </code></pre><p>　　当最后一个参数是以<em>*name的形式出现,表示函数接收一个字典类型（dict）参数（带有关键字的形参）。形参还可以</em>name的形式出现，表示函数接收一个元组（tuple）类型的参数。但如果函数参数列表中既要定义字典类型又有元组类型，字典类型一定要放在元组类型参数之后。比如下面例子：  </p><pre><code>def cheeseshop(kind,*arguments,**keywords):    print(&quot;--Do you have any &quot;,kind,&quot;?&quot;)    print(&quot;--I&apos;m sorry,We&apos;re all out off&quot;,kind)    for arg in arguments:        print(arg)    print(&quot;-&quot;*40)    for kw in keywords:        print(kw,&quot;:&quot;,keywords[kw])</code></pre><p>　　可以像下面调用函数：</p><pre><code>cheeseshop(&quot;Limburger&quot;,&quot;It&apos;s very runny,sir.&quot;,               &quot;It&apos;s really very runny ,sir.&quot;,             shopkeeper=&quot;Michael&quot;,client=&quot;John&quot;,            sketch=&quot;Cheese shop Sketch&quot;)  </code></pre><p>　　结果显示如下：　　</p><pre><code>--Do you have any  Limburger ?　　　　　　　＃　kind--I&apos;m sorry,We&apos;re all out off Limburger   ＃　kindIt&apos;s very runny,sir.                      ＃　argumentsIt&apos;s really very runny ,sir.              ＃　arguments----------------------------------------shopkeeper : Michael                     #keywordsclient : John                             #keywordssketch : Cheese shop Sketch               #keywords  </code></pre><p>　　</p><h3 id="任意参数列表"><a href="#任意参数列表" class="headerlink" title="任意参数列表"></a>任意参数列表</h3><p>　　最常见的做法是指定一个函数可以用任意数量的参数调用。这些参数将被封装在一个元组中（参见Tuples和序列）。在变量数目可变之前，可能出现零个或多个正常参数。  </p><pre><code>def  write_multiple_items(file,separator,*args)    file.write(separator.join(args))  </code></pre><p>　　一般情况下，可变参数放在形参列表的最后，因为它将会接收所有它之后传递过来的参数。任意在*args参数后定义赋值的参数只能是关键字参数，而不能是位置参数。</p><pre><code>def concat(*args,sep=&quot;/&quot;):    return sep.join(args)  print(concat(&quot;earth&quot;,&quot;Mars&quot;,&quot;venus&quot;))earth/Mars/venus  </code></pre><h3 id="Lambda函数（匿名函数）"><a href="#Lambda函数（匿名函数）" class="headerlink" title="Lambda函数（匿名函数）　　"></a>Lambda函数（匿名函数）　　</h3><p>　　小型匿名函数可以通过声明lambda关键字进行构建。像lambda a,b:a+b这个函数以a，b为参数，返回a,b的和。Lambda函数可以在任意需要定义函数的地方使用。但它们在语法上被限制为单句表达。像嵌套函数定义一样，lambda函数也可以引用其作用域内的变量：</p><pre><code>def make_incrementor(n):    return lambda x: x + nf = make_incrementor(42)f(1)43</code></pre><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><ol><li>使用4个空格进行代码层次区分，而不要使用TAB；</li><li>一行不要超过79个字符；</li><li>使用空白行将函数、类或在函数中的较大的代码块区分开；</li><li>尽可能将注释与需注释的代码放在同一行；</li><li>使用docstrings对代码进行说明；</li><li>在操作符和逗号前后尽量空一格；</li><li>定义类和函数名时风格尽量保持一致；通常做法是定义类使用骆驼拼写风格（SampleCase），定义函数和方法时使用lower_case_with_underscores的拼写风格。类的第一个方法使用self作为参数；</li><li>不要使用奇怪的编码方式去写代码；在任何情况下，Python默认的UTF-8，或者纯ASCII都是最好的编码方式；</li><li>同样地，如果使用不同语言的人阅读或维护代码的机会很小，请不要在标识符中使用非ASCII字符。</li></ol><p>#数据结构  </p><h3 id="list用作堆栈"><a href="#list用作堆栈" class="headerlink" title="list用作堆栈"></a>list用作堆栈</h3><p>　　列表方法使得使用列表作为堆栈（先进后出）非常容易。在堆栈顶部添加一个元素，可以使用append()。使用不带参数的pop()函数在堆栈顶部取出一个元素。比如：  </p><pre><code>&gt;&gt;&gt;stack=[3,4,5]&gt;&gt;&gt;stack.append(6)&gt;&gt;&gt;stack[3,4,5,6]&gt;&gt;&gt;stack.pop()6  </code></pre><h3 id="list用作队列"><a href="#list用作队列" class="headerlink" title="list用作队列"></a>list用作队列</h3><p>　　列表也可以被用作队列（先入先出），但列表用作队列并不方便。因为从队列底部插入和取出元素都很快，从队列头部很慢。<br>　　为实现一个队列，使用collections.deque,collections.deque能够实现列表两端的插入元素和取出元素。比如：  </p><pre><code>&gt;&gt;&gt;from collections import deque&gt;&gt;&gt;queue=deque([1,2,2,3,4])&gt;&gt;&gt;queue.append(&quot;mark&quot;)&gt;&gt;&gt;queue.popleft()1&gt;&gt;&gt;queue.popleft()2&gt;&gt;&gt;queuedeque([2,3,4,‘mark’])</code></pre><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>　　列表推导式提供了一个简洁的创建列表的方式。通常构建新列表元素的方法使根据一个序列或迭代器经过一些操作形成另一对应的结果，或满足特定条件下筛选出的子序列。比如：  </p><pre><code>&gt;&gt;&gt;s=[]&gt;&gt;&gt;for x in range(10):        s.append(x**3)&gt;&gt;&gt;s[0,1,8,27,64,125,216,343,512,729]</code></pre><p>　　也可以使用匿名函数形成列表：</p><pre><code>&gt;&gt;&gt;s=list(map(lambda x:x**2,range(5)))&gt;&gt;&gt;s[0,1,4,9,16]  </code></pre><p>　　也可以使用等式：  </p><pre><code>s=[x**2 for x in range(10)]&gt;&gt;&gt;[(x,y) for x in [1,2,3] for y in [3,1,4] if x!=y][(1,3),(1,4),(2,3),(2,1),(2,4),(3,1),(3,4)]  </code></pre><p>###嵌套列表推导式　　<br>　　　列表推导式的初始表达可以是任意的表达式，包括另一个列表推导式。例如下面的一个3*4的矩阵，它由一个内嵌3个长度为4的列表的列表形成：  </p><pre><code>&gt;&gt;&gt;matrix=[[1, 2, 3, 4],          [5, 6, 7, 8],          [9, 10, 11, 12]]  </code></pre><p>　　下面是转置该矩阵的列表推导式：</p><pre><code>&gt;&gt;&gt;[[row[i] for row in matrix] for i in range(4)][[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]  </code></pre><p>　　内嵌的列表推导式根据后面的for语句表达的顺序进行求值，因此上述推导式等价于：  </p><pre><code>&gt;&gt;&gt; transposed = []&gt;&gt;&gt; for i in range(4):  ...     transposed.append([row[i] for row in matrix])  ...&gt;&gt;&gt; transposed    [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]    </code></pre><p>　　进一步解析，等价于：</p><pre><code>&gt;&gt;&gt; transposed = []&gt;&gt;&gt; for i in range(4):...     transposed_row = []...     for row in matrix:...         transposed_row.append(row[i])...     transposed.append(transposed_row)...&gt;&gt;&gt; transposed[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]  </code></pre><p>　　也许在实际应用中，我们更喜欢用内置函数来实现复杂的表达式。zip（）函数可以很好的完成上述矩阵的转置：  </p><pre><code>&gt;&gt;&gt;list(zip(*matrix))[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]  </code></pre><h2 id="del表达式"><a href="#del表达式" class="headerlink" title="del表达式"></a>del表达式</h2><p>　　　del表达式可以根据列表的下标删除列表中的元素。这不同于pop()函数，pop()函数会返回元素的值，del不会。del表达式也可以使用切片删除列表中的多个元素，甚至删除整个列表。比如：</p><pre><code>&gt;&gt;&gt;a=[1,2,3,4,5,6]&gt;&gt;&gt;del a[0]&gt;&gt;&gt;a[2,3,4,5,6]&gt;&gt;&gt;del a[2:4]&gt;&gt;&gt;a[2,5,6]&gt;&gt;&gt;del a&gt;&gt;&gt;a........NameError: name &apos;a&apos; is not defined  </code></pre><h2 id="Tuples和序列"><a href="#Tuples和序列" class="headerlink" title="Tuples和序列"></a>Tuples和序列</h2><p>　　像list和string都是序列数据类型，它们有很多共同的特点，比如可以有下标，可以进行切片操作。Python语言中还存在另一种标准的序列数据类型：tuple。<br>　　定义tuple，tuple各元素之间用逗号隔开，比如：</p><pre><code>&gt;&gt;&gt;t=123,456,&apos;hi&apos;&gt;&gt;&gt;t(123,456,&apos;hi&apos;)&gt;&gt;&gt;t=(123,456,&apos;hi&apos;)  #定义tuple更标准的形式 &gt;&gt;&gt;t=tuple((123,456,&apos;hi&apos;)) #函数形式定义 &gt;&gt;&gt;u=t,(1,2,3,4)     #tuple还可以嵌套&gt;&gt;&gt;u((123,456,&apos;hi&apos;),(1,2,3,4))&gt;&gt;&gt;t[0]=0            #tuple是不可变序列Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;tuple&apos; object does not support item assignment&gt;&gt;&gt;v=([1,2,3],[3,2,1])   #tuple的元素可以是可变序列list&gt;&gt;&gt;v([1,2,3],[3,2,1])</code></pre><p>　　定义一些特殊的tuple类型对象，需要注意一些问题：</p><pre><code>&gt;&gt;&gt;empty=() #0个元素的tuple类型，一定要用括号&gt;&gt;&gt;m=&apos;hello&apos;, #定义一个元素的tuple类型，后面一定要加逗号 &gt;&gt;&gt;x,y,z=t&gt;&gt;&gt;x123&gt;&gt;&gt;y456&gt;&gt;&gt;z&apos;hi&apos;&gt;&gt;&gt;a,b=t......ValueError:not enough values to unpack(expected 2,got 1)  </code></pre><h2 id="集合（sets）"><a href="#集合（sets）" class="headerlink" title="集合（sets）"></a>集合（sets）</h2><p>　　set是一个无重复元素的无序合集。和数学中的概念一样，set也有并集、合集、差集等运算。</p><pre><code>&gt;&gt;&gt;basket={&apos;apple&apos;,&quot;orange&quot;,&apos;apple&apos;,&apos;pear&apos;,&apos;orange&apos;,&apos;banana&apos;}&gt;&gt;&gt;basket{&apos;orange&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;apple&apos;}  #自动删除重复元素&gt;&gt;&gt;basket=set((&apos;apple&apos;,&quot;orange&quot;,&apos;apple&apos;,&apos;pear&apos;,&apos;orange&apos;,&apos;banana&apos;))  #函数形式创建set&gt;&gt;&gt;&apos;orange&apos; in basket    True....&gt;&gt;&gt;a={&apos;qw&apos;,&apos;r&apos;}&gt;&gt;&gt;b={&apos;qw&apos;,&apos;m&apos;}&gt;&gt;&gt;a-b        #a,b的差集，只在a中元素的集合{&apos;r&apos;}&gt;&gt;&gt;a|b        #a,b的合集，在a或者在b中的元素的集合{&apos;m&apos;,&apos;qw&apos;,&apos;r&apos;}&gt;&gt;&gt;a&amp;b        #a,b的并集，同时在a,b中元素的集合{&apos;qw&apos;}&gt;&gt;&gt;a^b        #a，b集合的异或，在a或者b中，但不在a,b的并集中元素的集合{&apos;m&apos;,&apos;r&apos;}  </code></pre><p>　　同样，像list推导式，set推导式也是被支持的：</p><pre><code>&gt;&gt;&gt;a={x for x in &quot;abracadabra&quot; if x not in &apos;abc&apos;}&gt;&gt;&gt;a{&apos;r&apos;,&apos;a&apos;}  </code></pre><h2 id="字典（dict）"><a href="#字典（dict）" class="headerlink" title="字典（dict）"></a>字典（dict）</h2><p>　　dict（字典）是Python语言中一种很有用的数据类型。在其他语言中dict被称为关联内存或关联数组。不同于序列由一列数字索引，字典由关键字索引，关键字可以是任意的非变类型；所有字符串和数字都可以作为字典的关键字。tuple类型只有当其元素不含可变类型数据时可以作为关键字。list类型不能被用作字典的关键字。<br>　　理解字典类型，最好将它看成一个无序的key:value组的集合，在一个字典里，每个关键字是唯一的。一对花括号创建一个空的字典：{}。每个key:value对之间用逗号隔开。  </p><pre><code>&gt;&gt;&gt;tel={&apos;jack&apos;: 4098, &apos;sape&apos;: 4139,&apos;jack&apos;:3022}&gt;&gt;&gt;tel{&apos;jack&apos;:3022,&apos;sape&apos;: 4139}      #重复的关键字会保留最后一组key:value对，其他自动删除。&gt;&gt;&gt;tel[&apos;lili&apos;]=4423              #增加字典元素&gt;&gt;&gt;tel{&apos;jack&apos;:3022,&apos;sape&apos;: 4139,&apos;lili&apos;:4423}&gt;&gt;&gt;del tel[&apos;sape&apos;]&gt;&gt;&gt;tel{&apos;jack&apos;:3022,&apos;lili&apos;:4423}&gt;&gt;&gt;list(tel.keys())[&apos;jack&apos;,&apos;lili&apos;]&gt;&gt;&gt;sorted(tel.keys())[&apos;jack&apos;,&apos;lili&apos;]&gt;&gt;&gt;sorted(tel.values())[3022,4423]&gt;&gt;&gt;&apos;jack&apos; in telTrue</code></pre><p>　　dict()直接根据key-value序列创建字典：  </p><pre><code>&gt;&gt;&gt; dict([(&apos;sape&apos;, 4139), (&apos;guido&apos;, 4127), (&apos;jack&apos;, 4098)]){&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127}  </code></pre><p>　　字典推导式可以根据任意的关键字和值创建字典：  </p><pre><code>&gt;&gt;&gt;{x:x**2 for x in(1,2,3)}{1:1,2:4,3:9}  </code></pre><p>　　当关键字只为字符串，可以简化字典类型的创建：  </p><pre><code>&gt;&gt;&gt;dict(sape=4139, guido=4127, jack=4098){&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127}</code></pre><h2 id="循环技巧"><a href="#循环技巧" class="headerlink" title="循环技巧"></a>循环技巧</h2><p>　　当遍历字典时，关键字和相关的值可以通过items()方法同时提取。</p><pre><code>&gt;&gt;&gt; knights = {&apos;gallahad&apos;: &apos;the pure&apos;, &apos;robin&apos;: &apos;the brave&apos;}&gt;&gt;&gt; for k, v in knights.items():...     print(k, v)...gallahad the purerobin the brave  </code></pre><p>　　当遍历一个序列时，元素的位置和值可以通过enumerate()函数同时获取。  </p><pre><code>&gt;&gt;&gt; for i, v in enumerate([&apos;tic&apos;, &apos;tac&apos;, &apos;toe&apos;]):...     print(i, v)...0 tic1 tac2 toe  </code></pre><p>　　同时遍历两个序列，可以使用zip()函数：                 </p><pre><code>&gt;&gt;&gt; questions = [&apos;name&apos;, &apos;quest&apos;, &apos;favorite color&apos;]&gt;&gt;&gt; answers = [&apos;lancelot&apos;, &apos;the holy grail&apos;, &apos;blue&apos;]&gt;&gt;&gt; for q, a in zip(questions, answers):...     print(&apos;What is your {0}?  It is {1}.&apos;.format(q, a))...What is your name?  It is lancelot.What is your quest?  It is the holy grail.What is your favorite color?  It is blue.  </code></pre><p>　　反序遍历序列，调用reversed()函数，排序使用sorted()函数：</p><pre><code>&gt;&gt;&gt; for i in reversed(range(1, 10, 2)):   #resversed()返回的是一个迭代器类，而不是反序后的序列。...     print(i)...97531  </code></pre><p>　　有时候想在遍历序列的时候改变它，简单而又安全的方法是将新建一个序列。</p><pre><code>&gt;&gt;&gt; import math&gt;&gt;&gt; raw_data = [56.2, float(&apos;NaN&apos;), 51.7, 55.3, 52.5, float(&apos;NaN&apos;), 47.8]&gt;&gt;&gt; filtered_data = []&gt;&gt;&gt; for value in raw_data:...     if not math.isnan(value):...         filtered_data.append(value)...&gt;&gt;&gt; filtered_data[56.2, 51.7, 55.3, 52.5, 47.8]  </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python基础&quot;&gt;&lt;a href=&quot;#Python基础&quot; class=&quot;headerlink&quot; title=&quot;Python基础&quot;&gt;&lt;/a&gt;Python基础&lt;/h1&gt;&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;h3 id=&quot;整数和浮点、复数&quot;&gt;&lt;a href=&quot;#整数和浮点、复数&quot; class=&quot;headerlink&quot; title=&quot;整数和浮点、复数&quot;&gt;&lt;/a&gt;整数和浮点、复数&lt;/h3&gt;&lt;p&gt;　　Python可以处理任意大的整数和浮点数，整数为int类型，浮点数为float类型。整数和浮点数均能够通过＋、－、*、/进行加减乘除运算。
    
    </summary>
    
      <category term="Python" scheme="http://focusok.xyz/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>撩起你的胃口</title>
    <link href="http://focusok.xyz/2017/03/18/%E6%92%A9%E8%B5%B7%E4%BD%A0%E7%9A%84%E8%83%83%E5%8F%A3/"/>
    <id>http://focusok.xyz/2017/03/18/撩起你的胃口/</id>
    <published>2017-03-18T12:39:35.000Z</published>
    <updated>2018-01-07T12:20:12.047Z</updated>
    
    <content type="html"><![CDATA[<p>　　如果你要在电脑上处理大量的工作，最终你发现有一些工作你想要电脑自动化处理。比如：你希望在一大堆文本中进行‘查找并替换’的操作，或者以一种复杂的方式去给大量的图片重命名和重排序。或者你想要写一个小的本地数据库，或一个特别的界面应用，或是简单的小程序。<a id="more"></a><br>　　如果你是一个专业的软件开发者，你可能不得不使用几个C/C++/JAVA语言的库但发现通常的编写、编译、测试、重编译的周期很慢。也许你正在为一个代码库写测试套件，但发现编写测试代码是个巨大的工程。或者你已经写好了一个程序并希望这个程序能够使用其他扩展性的语言，而你并不希望用新语言去重新去完成整个程序的设计。<br>　　在所有上述提到的情景下，Python语言都是你最好的选择。<br>　　你可以编写Unix shell脚本或者Windows批处理文件去处理上述的任务，但shell脚本比较适合处理文件移动和文本数据更改，并不适合界面应用和游戏。你可以写C/C++/Java程序，但即使是完成程序草稿，也将会花费你大量时间。Python简单易用，可以兼容Windows，Mac OS X,以及Unix操作系统，并将帮助你更快速的处理那些任务。<br>　　Python简单而又实用，但它是一门真正的语言。比起shell脚本和批处理文件，它提供更多的结构和对大型项目的支持。另一方面，Python比C语言提供更多的错误检查，并且，作为一种高级语言，它内置高级数据类型，比如复杂的矩阵和字典类型。因为Python语言更通用的数据类型，使它在解决很多问题上比Awk甚至Perl语言更适合，至少很多东西在Python中处理和在那些语言中一样简单。<br>　　Python允许你将代码封装成组件，这样就可在其他Python程序中复用这些组件。当然也有大量的标准组件，你可以用作构建你程序的基础或者作为学习Python编程的示例。这些组件能够提供像文件I/O、系统响应、网络协议甚至像Tk这样的图形界面工具。<br>　　Python是一种解释性语言，这将会在程序开发的过程中节省你大量的时间，因为Python程序不需要编译和连接。Python解释器能够交互式去编写代码而不需要过多考虑整个程序，或者在自下而上开发过程中去测试功能，这使得很容易使用它去验证Python语言的每一个特性。当然，它还是一个方便的桌面计算器。<br>　　Python使程序简洁易读。下面几个原因使得使用Python编写的程序比用C、C++或Java编写的程序短的多：<br>　　1. 高级数据类型使你能使用简单的描述处理复杂的操作<br>　　2. 声明代码组由缩进代替了开始和结束括号<br>　　3. 不需要特意声明变量和参数<br>　　Python是可扩展的：如果你知道用C语言编程，那向解释器添加新内置函数和新组件将会很简单，无论是你想要程序以最大的速度进行关键的操作，还是连接Python代码到程序库，但这些扩展可能只能以操作二进制格式的文件进行（比如特定于供应商的图形库）。如果你真的对此感兴趣，你可以把Python解释器连接到用C语言编写的程序中并把它作为这个程序的扩展或命令语言。<br>　　顺便一提，Python语言是根据BBC喜剧片“Monty Python’s Flying Circus”命名的，无关乎爬行动物Python（巨蟒）。Monty Python短剧的引用不仅是允许的，而且是被鼓励的。<br>　　现在你对Python已经感到激动了，并想更详细的去检测它。因为学习语言的最好方式是去使用它，此教程要求当你阅读的同时使用Python解释器去使用它。<br>　　在下一章，将会分析解释器的运用机制，这些分析虽然很枯燥常见，但对后面成功实践示例很重要。<br>　　教程其他部分会通过例子介绍大量Python语言系统的特性，开始介绍简单的表达式、声明和数据类型，然后介绍函数和模块，最后接触像异常和自定义类等先进的概念。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　如果你要在电脑上处理大量的工作，最终你发现有一些工作你想要电脑自动化处理。比如：你希望在一大堆文本中进行‘查找并替换’的操作，或者以一种复杂的方式去给大量的图片重命名和重排序。或者你想要写一个小的本地数据库，或一个特别的界面应用，或是简单的小程序。
    
    </summary>
    
      <category term="翻译·Python教程" scheme="http://focusok.xyz/categories/%E7%BF%BB%E8%AF%91%C2%B7Python%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Python教程</title>
    <link href="http://focusok.xyz/2017/03/16/python%E6%95%99%E7%A8%8B/"/>
    <id>http://focusok.xyz/2017/03/16/python教程/</id>
    <published>2017-03-16T15:30:19.000Z</published>
    <updated>2018-01-07T12:20:56.637Z</updated>
    
    <content type="html"><![CDATA[<p>　　本教程翻译自Python官网<a href="https://docs.python.org/3/" target="_blank" rel="external">python教程</a>。<br>　　Python是一种强大、易学的编程语言。它拥有高效的高级数据结构，能够使用简单但有效的方式进行面向对象编程的。Python优雅的语法、动态类型以及自然的语言解析，使它成为许多领域大多数平台脚本处理和快速开发应用的理想语言。 <a id="more"></a><br>　　在<a href="https://www.python.org/" target="_blank" rel="external">Python网站</a>上的Python解释器和标准的扩展库均是开源的，它们能够兼容所有主流系统平台，你可以自由获取它们的源代码或者二进制文件，并可以自由分发。网站还提供了很多免费的第三方Python组件、应用程序、工具和附加的文档说明。<br>　　Python解释器很容易扩展新功能，你能够扩展嵌入使用C或者C++（或其他从C语言发展而来的语言）执行的数据格式。Python也很适于作为本地应用的扩展语言。<br>　　此教程非正式地向读者介绍Python语言系统的基本思想和特性。在实际实践中结合使用Python解释器对Python的学习是很有帮助的，但所有的例子都是完整独立的，因此此教程也能够离线阅读。<br>　　标准组件和元件的说明参见<a href="http://docs.python.org/3/library/index.html#library-index" target="_blank" rel="external">Python标准库</a>。<a href="http://docs.python.org/3/reference/index.html#library-index" target="_blank" rel="external">Python语言参考</a>对Python语言中的定义有更正式的说明。想要在C或C++中扩展Python可以参考<a href="http://docs.python.org/3/extending/index.html#extending-index" target="_blank" rel="external">Python解释器的扩展和嵌入</a>和<a href="http://docs.python.org/3/c-api/index.html#c-api-index" target="_blank" rel="external">Python/C API参考手册</a>。当然还有其他深入介绍Python的书籍。<br>　　此教程不会尝试涵盖Python的所有特性，甚至不会完全涵盖说明所有的常用特性。相反，它会集中介绍Python中最引人注目的特性，并将带给你对语言风格的认识。经此教程，你将能够读写Python组件和应用程序，也为你以后阅读使用<a href="http://docs.python.org/3/library/index.html#library-index" target="_blank" rel="external">Python标准库</a>中更多丰富的Python标准库组件做好准备。<br>　　教程目录  </p><ol><li>Whetting Your Appetite  </li><li>Using the Python Interpreter<br>2.1  Invoking the Interpreter<br>  2.1.1  Argument Passing<br>   2.1.2  Interactive Mode<br>2.2. The Interpreter and Its Environment<br>   2.2.1 Source Code Encoding</li><li>An Informal Introduction to Python<br> 3.1. Using Python as a Calculator<br>   3.1.1. Numbers<br>   3.1.2. Strings<br>   3.1.3. Lists<br> 3.2. First Steps Towards Programming</li><li>More Control Flow Tools<br> 4.1. if Statements<br> 4.2. for Statements<br> 4.3. The range() Function<br> 4.4. break and continue Statements, and else Clauses on Loops<br> 4.5. pass Statements<br> 4.6. Defining Functions<br> 4.7. More on Defining Functions<br>   4.7.1. Default Argument Values<br>   4.7.2. Keyword Arguments<br>   4.7.3. Arbitrary Argument Lists<br>   4.7.4. Unpacking Argument Lists<br>   4.7.5. Lambda Expressions<br>   4.7.6. Documentation Strings<br>   4.7.7. Function Annotations<br> 4.8. Intermezzo: Coding Style</li><li>Data Structures<br>5.1. More on Lists<br>   5.1.1. Using Lists as Stacks<br>   5.1.2. Using Lists as Queues<br>   5.1.3. List Comprehensions<br>   5.1.4. Nested List Comprehensions<br>5.2. The del statement<br>5.3. Tuples and Sequences<br>5.4. Sets<br>5.5. Dictionaries<br>5.6. Looping Techniques<br>5.7. More on Conditions<br>5.8. Comparing Sequences and Other Types</li><li>Modules<br>6.1. More on Modules<br>   6.1.1. Executing modules as scripts<br>   6.1.2. The Module Search Path<br>   6.1.3. “Compiled” Python files<br>6.2. Standard Modules<br>6.3. The dir() Function<br>6.4. Packages<br>   6.4.1. Importing * From a Package<br>   6.4.2. Intra-package References<br>   6.4.3. Packages in Multiple Directories</li><li>Input and Output<br>7.1. Fancier Output Formatting<br>   7.1.1. Old string formatting<br>7.2. Reading and Writing Files<br>   7.2.1. Methods of File Objects<br>   7.2.2. Saving structured data with json</li><li>Errors and Exceptions<br>8.1. Syntax Errors<br>8.2. Exceptions<br>8.3. Handling Exceptions<br>8.4. Raising Exceptions<br>8.5. User-defined Exceptions<br>8.6. Defining Clean-up Actions<br>8.7. Predefined Clean-up Actions</li><li>Classes<br>9.1. A Word About Names and Objects<br>9.2. Python Scopes and Namespaces<br>   9.2.1. Scopes and Namespaces Example<br>9.3. A First Look at Classes<br>   9.3.1. Class Definition Syntax<br>   9.3.2. Class Objects<br>   9.3.3. Instance Objects<br>   9.3.4. Method Objects<br>   9.3.5. Class and Instance Variables<br>9.4. Random Remarks<br>9.5. Inheritance<br>9.5.1. Multiple Inheritance<br>9.6. Private Variables<br>9.7. Odds and Ends<br>9.8. Iterators<br>9.9. Generators<br>9.10. Generator Expressions</li><li>Brief Tour of the Standard Library<br>10.1. Operating System Interface<br>10.2. File Wildcards<br>10.3. Command Line Arguments<br>10.4. Error Output Redirection and Program Termination<br>10.5. String Pattern Matching<br>10.6. Mathematics<br>10.7. Internet Access<br>10.8. Dates and Times<br>10.9. Data Compression<br>10.10. Performance Measurement<br>10.11. Quality Control<br>10.12. Batteries Included</li><li>Brief Tour of the Standard Library — Part II<br>11.1. Output Formatting<br>11.2. Templating<br>11.3. Working with Binary Data Record Layouts<br>11.4. Multi-threading<br>11.5. Logging<br>11.6. Weak References<br>11.7. Tools for Working with Lists<br>11.8. Decimal Floating Point Arithmetic</li><li>Virtual Environments and Packages<br>12.1. Introduction<br>12.2. Creating Virtual Environments<br>12.3. Managing Packages with pip</li><li>What Now?</li><li>Interactive Input Editing and History Substitution<br>14.1. Tab Completion and History Editing<br>14.2. Alternatives to the Interactive Interpreter</li><li>Floating Point Arithmetic: Issues and Limitations<br>15.1. Representation Error</li><li>Appendix<br>16.1. Interactive Mode<br>  16.1.1. Error Handling<br>  16.1.2. Executable Python Scripts<br>  16.1.3. The Interactive Startup File<br>  16.1.4. The Customization Modules　　 　　 　　</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本教程翻译自Python官网&lt;a href=&quot;https://docs.python.org/3/&quot;&gt;python教程&lt;/a&gt;。&lt;br&gt;　　Python是一种强大、易学的编程语言。它拥有高效的高级数据结构，能够使用简单但有效的方式进行面向对象编程的。Python优雅的语法、动态类型以及自然的语言解析，使它成为许多领域大多数平台脚本处理和快速开发应用的理想语言。
    
    </summary>
    
      <category term="翻译" scheme="http://focusok.xyz/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="python" scheme="http://focusok.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+github建站配置</title>
    <link href="http://focusok.xyz/2017/02/26/myfirstblog/"/>
    <id>http://focusok.xyz/2017/02/26/myfirstblog/</id>
    <published>2017-02-26T10:30:19.000Z</published>
    <updated>2018-01-07T12:20:40.461Z</updated>
    
    <content type="html"><![CDATA[<p><center></center></p><h1 id="Hexo-Github建站"><a href="#Hexo-Github建站" class="headerlink" title="Hexo+Github建站"></a>Hexo+Github建站</h1><h3 id="使用hexo和Gitpage建站配置"><a href="#使用hexo和Gitpage建站配置" class="headerlink" title="使用hexo和Gitpage建站配置"></a>使用hexo和Gitpage建站配置</h3><p>　　第一次使用hexo和GitPage建立自己的个人博客。如何用hexogithub创建自己的个人博客，这个自不必多说，网上有很多教程，参照教程就可以很简单将网站搭建起来，当然在这推荐<a href="http://www.cnblogs.com/MuYunyun/p/5927491.html" target="_blank" rel="external">http://www.cnblogs.com/MuYunyun/p/5927491.html</a>,这个教程讲的不能再详细了。当然遇到hexo上的问题，可以参考<a href="https://hexo.io/docs/" target="_blank" rel="external">hexo官网文档</a>，讲的也简单易懂。<a id="more"></a></p><h3 id="添加多说评论插件"><a href="#添加多说评论插件" class="headerlink" title="添加多说评论插件"></a>添加多说评论插件</h3><p>　　Hexo默认评论插件是Disqus，但Disqus访问较慢，需要注册,比较麻烦，多说可以用微博、qq等登录，无需注册，操作起来很方便.添加多说的步骤可以参考这个教程<a href="http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9" target="_blank" rel="external">http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9</a>.里面要提的是duoshuo_shortname的设置就是第一次登录多说在多说中设置的二级域名除掉.duoshuo.com的部分，比如我当时设置的是<a href="http://focusok.duoshuo.com,那么duoshuo_shortname设置为focusok。" target="_blank" rel="external">http://focusok.duoshuo.com,那么duoshuo_shortname设置为focusok。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;h1 id=&quot;Hexo-Github建站&quot;&gt;&lt;a href=&quot;#Hexo-Github建站&quot; class=&quot;headerlink&quot; title=&quot;Hexo+Github建站&quot;&gt;&lt;/a&gt;Hexo+Github建站&lt;/center&gt;&lt;/h1&gt;&lt;h3 id=&quot;使用hexo和Gitpage建站配置&quot;&gt;&lt;a href=&quot;#使用hexo和Gitpage建站配置&quot; class=&quot;headerlink&quot; title=&quot;使用hexo和Gitpage建站配置&quot;&gt;&lt;/a&gt;使用hexo和Gitpage建站配置&lt;/h3&gt;&lt;p&gt;　　第一次使用hexo和GitPage建立自己的个人博客。如何用hexogithub创建自己的个人博客，这个自不必多说，网上有很多教程，参照教程就可以很简单将网站搭建起来，当然在这推荐&lt;a href=&quot;http://www.cnblogs.com/MuYunyun/p/5927491.html&quot;&gt;http://www.cnblogs.com/MuYunyun/p/5927491.html&lt;/a&gt;,这个教程讲的不能再详细了。当然遇到hexo上的问题，可以参考&lt;a href=&quot;https://hexo.io/docs/&quot;&gt;hexo官网文档&lt;/a&gt;，讲的也简单易懂。
    
    </summary>
    
      <category term="网站" scheme="http://focusok.xyz/categories/%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="配置" scheme="http://focusok.xyz/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
</feed>
