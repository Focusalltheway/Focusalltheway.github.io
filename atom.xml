<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hurrican</title>
  <icon>https://www.gravatar.com/avatar/aa3c406e9be772646e8349e7f61092c9</icon>
  <subtitle>走自己的路，让别人去说</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://focusok.xyz/"/>
  <updated>2018-06-11T17:24:46.655Z</updated>
  <id>http://focusok.xyz/</id>
  
  <author>
    <name>hurricane</name>
    <email>hurricanhup@sina.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python学习</title>
    <link href="http://focusok.xyz/2018/01/21/python%E5%AD%A6%E4%B9%A0/"/>
    <id>http://focusok.xyz/2018/01/21/python学习/</id>
    <published>2018-01-21T15:17:40.000Z</published>
    <updated>2018-06-11T17:24:46.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数、浮点数和复数"><a href="#整数、浮点数和复数" class="headerlink" title="整数、浮点数和复数"></a>整数、浮点数和复数</h3><p>　　Python可以处理任意大的整数和浮点数，整数为int类型，浮点数为float类型。整数和浮点数均能够通过＋、－、*、/进行加减乘除运算。<a id="more"></a>    </p><pre><code>&gt;&gt;&gt;2+2   4    &gt;&gt;&gt;&gt;5/2  2.5  &gt;&gt;&gt;5*1.8  9.0</code></pre><p>　　一般除法运算/得到的数据类型默认为浮点数类型，如果想得到商的整数部分，使用//,想得到余数使用%。  </p><pre><code>&gt;&gt;&gt;5//2  2  &gt;&gt;&gt;5%2  1</code></pre><p> 　　在Python中，**相当于幂运算。  </p><pre><code>&gt;&gt;&gt;3**3  27&gt;&gt;&gt;(-3)**29</code></pre><p>　　Python还内置了复数的定义和运算，’j’或J表示虚部，复数一般表示为a+bj。  </p><pre><code>&gt;&gt;&gt;(3+2j)/(1+5j)  (0.5-0.5j)&gt;&gt;&gt;(1+3j)*(2+2j)  (-4+8j)</code></pre><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>　　除了数字Python还能操作字符串。字符串可以使用单引号’…’或者双引号”…”的方式表示，若引号内有引号为字符串的内容，使用\排除歧义。  </p><pre><code>&gt;&gt;&gt;&apos;hello world&apos;  &apos;hello world&apos;&gt;&gt;&gt;&apos;Lilei\&apos;s hat&apos;&quot;Lilei&apos;s hat&quot;&gt;&gt;&gt;&apos;Lilei say:&quot;how are you？&quot;&apos;&apos;Lilei say:&quot;how are you？&quot;&apos;&gt;&gt;&gt;&quot;\&quot;yes,\&quot;he said&quot;&apos;&quot;yes,&quot;he said&apos;  &gt;&gt;&gt;&apos;&quot;yes,you are good,&quot;he said.&apos;&apos;&quot;yes,you are good,&quot;he said.&apos; #单引号中的双引号不产生歧义  &gt;&gt;&gt;&quot;isn&apos;t he?&quot;  &quot;isn&apos;t he?&quot;  #双引号中的单引号也不产生歧义  </code></pre><p>　　如果不想将\解释为转义字符，只需要在引用号前加r，表示原生（raw）保留。  </p><pre><code>&gt;&gt;&gt;print(&apos;C:\X\name&apos;)  #\n为换行字符C:\X  ame  &gt;&gt;&gt;print(r&apos;C:\X\name&apos;)  C:\X\name  </code></pre><p>　　字符串还可以使用+进行合并操作，使用*作为重复操作。（没有-和/的运算）  </p><pre><code>&gt;&gt;&gt;3*&apos;im&apos;&apos;imimim&apos;&gt;&gt;&gt;3*&apos;im&apos;+&apos;k&apos;  &apos;imimimk&apos;   </code></pre><p>　　<br>  　字符串可以根据下标读取内容，第一个字符下标为０.但下标所取超出实际下标范围将会报错。　　</p><pre><code>&gt;&gt;&gt;word=&apos;python&apos;  &gt;&gt;&gt;word[0]  &apos;p&apos;  &gt;&gt;&gt;word[5]&apos;n&apos;&gt;&gt;&gt;word[-1] #最后一个字符&apos;n&apos;&gt;&gt;&gt;word[-2] #倒数第二个字符&apos;o&apos;&gt;&gt;&gt;word[20]...IndexError:string index out of range</code></pre><p>　　    字符串还可以进行切片运算进行部分字符的选取。切片运算a[x:y:z],表示字符串a中从下标x开始步进为z取字符，取到下标为y截止所组成的字符串。但切片运算下标超出范围时，将不会报故障。  </p><pre><code>&gt;&gt;&gt;word=&apos;abcdefghijklmn&apos;&gt;&gt;&gt;word[1:4] #默认为word[1:4:1]&apos;bcd&apos;&gt;&gt;&gt;word[1:8:2]&apos;bdfh&apos;&gt;&gt;&gt;word[-8:8:2]&apos;fh&apos; &gt;&gt;&gt;word[18:20] &apos; &apos;           #返回空  </code></pre><p>　　字符串不允许使用下标对单个或部分字符直接赋值来改变字符串。  </p><pre><code>&gt;&gt;&gt;word[0]=&apos;k&apos;...TypeError: &apos;str&apos; object does not support item assignment&gt;&gt;&gt;word[1:]=&apos;bcdefghijklmn&apos;...TypeError: &apos;str&apos; object does not support item assignment  </code></pre><p>　   内置函数len()返回字符串的长度。  </p><pre><code>&gt;&gt;&gt;len(&apos;abcde&apos;)5 &gt;&gt;&gt;len(&apos;你好！&apos;)3  </code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>　　Python中内置很多聚合型数据类型将不同的值聚合在一起。其中最重要最常见的莫过于列表了。列表使用一对方括号将不同数据组合在一起，这些组合的数据可以是不同的数据格式。  </p><pre><code>&gt;&gt;&gt;s=[1,2,3]&gt;&gt;&gt;s[1,2,3]&gt;&gt;&gt;a=[1,&apos;b&apos;]&gt;&gt;&gt;a[1,&apos;b&apos;]</code></pre><p>　　和字符串一样（任何其他内置的序列类型数据），列表也可以进行切片操作。  </p><pre><code>&gt;&gt;&gt;s[1:-1][2]&gt;&gt;&gt;s[1:][2,3]  </code></pre><p>　　列表也可以使用“+”操作符，进行连接操作。</p><pre><code>&gt;&gt;&gt;s+[3,4,5,6,7][1,2,3,3,4,5,6,7]  </code></pre><p>　　但列表不同于字符串的是列表是可以更改的，列表可以直接通过下标进行赋值。</p><pre><code>&gt;&gt;&gt;cube=[1,8,27,67,125]&gt;&gt;&gt;cube[1,8,27,67,125]&gt;&gt;&gt;cube[3]=64&gt;&gt;&gt;cube[1,8,27,64,125]&gt;&gt;&gt;cube[0:3]=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]&gt;&gt;&gt;cube[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,64,125]  &gt;&gt;&gt;cube[0:3]=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]&gt;&gt;&gt;cube[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,64,125]  </code></pre><p>　　　可以使用append()函数在列表后面添加元素。</p><pre><code>&gt;&gt;&gt;cube.append(6**3)&gt;&gt;&gt;cube[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,64,125,216]  </code></pre><p>　　　同样len（）函数也可以返回列表的长度（元素个数）。</p><pre><code>&gt;&gt;&gt;len([1,2],3)  #列表的元素可以是列表2  </code></pre><h2 id="通往Python编程的第一步"><a href="#通往Python编程的第一步" class="headerlink" title="通往Python编程的第一步"></a>通往Python编程的第一步</h2><p>　　当然，使用Python可以完成比计算更复杂的任务。比如，可以使用Python写出Fibonacci数列：  </p><pre><code>&gt;&gt;&gt;#Fibonacci series:...a,b=0,1&gt;&gt;&gt;while b&lt;10:...     print(b)...     a,b=b,a+b...12358</code></pre><p>　　<br>　　上述代码中第一行以#开头为注释，无其他作用，仅是说明下面代码完成的功能是打印Fibonacci数列，第2行定义两变量并赋初值为0、1，接下来是一个While循环，在循环的条件b&lt;10的情况下进行打印b值和累加。不同于C或C++语言，整个代码结构层次不使用；和{}进行区别，而是使用缩进量，两行代码缩进相同，表示进行的操作在同一个层级。</p><h2 id="流控制语句"><a href="#流控制语句" class="headerlink" title="流控制语句"></a>流控制语句</h2><p>　　除了while循环语句，和其他语言一样，Python还有很多其他流控制语句。  </p><h3 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h3><p>　　最常用的语句莫过于if条件语句，如下例：  </p><pre><code>&gt;&gt;&gt;a=int(input(&quot;Please enter an integer:&quot;))Please enter an integer:25&gt;&gt;&gt;if x&lt;0:          x=0        print(&apos;Negative changed to 0&apos;)    elif x==0:        print(&apos;0&apos;)    elif x==1:        print(&apos;Single&apos;)    else:        print(&apos;More&apos;)  ...  More</code></pre><h3 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h3><p>　　for循环语句可能在Python中和C语言中稍微有点不一样。C语言中for循环语句一般给出循环的起始值、步进和结束值，Python中for语句按照特定的序列进行循环。例如：</p><pre><code>&gt;&gt;&gt;words=[&apos;cat&apos;,&apos;window&apos;,&apos;difference&apos;]&gt;&gt;&gt;for i in words:        print(i,len(i))...cat 3window 6difference 10</code></pre><p>　　如果需要根据循环的条件序列改变序列本身，最好先将序列的复制作为循环条件：</p><pre><code>&gt;&gt;&gt;for i in words[:]:  #该切片操作相当于words的复制，如果此处直接是 i in words，程序将会导致编译器死循环。        if len(i)&gt;6:            words.insert(0,i)...&gt;&gt;&gt;words[&apos;difference&apos;,&apos;cat&apos;,&apos;window&apos;,&apos;difference&apos;]</code></pre><h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h3><p>　　使用内置函数range()可以构建序列。</p><pre><code>&gt;&gt;&gt;for i in range(3):        print(i)...012&gt;&gt;&gt;list(range(5,10))[5,6,7,8,9]&gt;&gt;&gt;list(range(0,10,3))[0,3,6,9]</code></pre><p>　　　　结合range()和len()，可以产生C语言中for语句的效果。  </p><pre><code>&gt;&gt;&gt;a=[&apos;Peter&apos;,&apos;is&apos;,&apos;a&apos;,&apos;boy&apos;]&gt;&gt;&gt;for i in range(len(a)):        print(i,a[i])...0 Peter1 is 2 a  3 boy</code></pre><h3 id="break和continue以及循环中的else语句"><a href="#break和continue以及循环中的else语句" class="headerlink" title="break和continue以及循环中的else语句"></a>break和continue以及循环中的else语句</h3><p>　　同C语言中一样，break语句也是跳出最接近break一层的for或者while循环。<br>　　循环中也可以有else语句；当for循环终止或while循环判断条件为false时，跟在后面的else语句会运行一次，但如果有break语句提前终止循环，else语句将不会运行。  </p><pre><code>&gt;&gt;&gt;prime=[]&gt;&gt;&gt;for n in range(2,10):           for x in prime:            if n%x==0:            print(n,&apos;equals&apos;,x,&apos;*&apos;,n//x)            break            else:        #此处else语句不与if为一层，而是与for循环为一对            prime.append(n)            print(n,&apos;is a prime&apos;)    2 is a prime        #for x  in prime:循环运行终止，未遇到break跳出循环，else语句运行一次。    3 is a prime    4 equals 2 * 2      #break跳出循环，else语句未运行    5 is a prime    6 equals 2 * 3    7 is a prime    8 equals 2 * 4    9 equals 3 * 3</code></pre><p>　　continue语句也是从C语言中借鉴过来的，也是跳过当次循环中continue之后的操作。</p><pre><code>&gt;&gt;&gt;for num in range(2,5):        if num%2==0:            print(&quot;found an even number&quot;,num)            continue        print(&quot;Found a odd num&quot;,num)    found an even number 2    found an odd num 3    found an even number 4</code></pre><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>　　我们举一个打印任意范围内的Fibonacci数列的例子来说明如何定义函数：  </p><pre><code>&gt;&gt;&gt;def fib(n):          #函数实现打印n以内的Fibonacci数列        a,b=0,1        while a&lt;n:            print(a,end=&quot; &quot;)            a,b=b,a+b        print()&gt;&gt;&gt;fib(200)0 1 1 2 3 5 8 13 21 34 55 89 144   </code></pre><p>　　如上述例子，函数的定义以def作为关键字，后面紧跟着函数名称（例子中fib），括号内为函数参数列表，函数主体另起一行开始，且和关键字要有缩进。函数第一行一般会以#添加注释，以说明函数的功能或其他信息，添加注释是个很好的习惯，有很多工具可以根据这些注释自动生成说明文档，也使别人浏览代码时更简单易懂。<br>　　函数的执行会引进一个新的本地符号列表用以存储函数的局部变量。更确切的说，函数中所有变量的配置值存储在本地符号列表里；但是变量的引用会先在本地符号列表中查找，如果本地列表中没有，然后在封闭函数的本地变量列表中查找，接着是全局符号列表，最后还没找到，才会访问内置名称表中进行查找。因此全局变量不能在函数内部直接赋值（除非对变量进行了全局声明），虽然全局变量也可以被引用。<br>　　调用函数时，在函数的本地符号列表中引入函数调用的实际参数；因此，参数使用按特定值调用（这个特定值始终是调用对象的引用，而不是调用对象的值）。当一个函数调用另一个函数时，就会为该调用新建一个本地符号列表。<br>　　函数定义在当前符号表中引入函数名。函数名的值有一个被解释器作为用户定义函数识别的类型。该值可以分配给另一个名称，该名称也可以用作函数。这就是Python中重命名机制：  </p><pre><code>&gt;&gt;&gt;fib&lt;function fib at 0x0000000001D13E18&gt;&gt;&gt;&gt;f=fib&gt;&gt;&gt;f(20)0 1 1 2 3 5 8 13</code></pre><p>　　<br>　　上述函数并不返回值，也许你会因此而认为它不应该是一个函数而应该只是个执行过程。但实际上，及时函数没有return返回声明但还是会返回一个值；这个值被称为None（它是一个内置名）。如果None是函数唯一的返回值时，解释器一般会忽略这个返回值。如果想看到这个返回值，可以使用print():  </p><pre><code>&gt;&gt;&gt;fib(0)&gt;&gt;&gt;print(fib(0))None&gt;&gt;&gt;print(fib(20))0 1 1 2 3 5 8 13None</code></pre><p>　　要想返回Fibonacci序列很简单：</p><pre><code>&gt;&gt;&gt;def fib2(n):  #返回n以内的Fibonacci序列        result=[]        a,b=0,1        while a&lt;n:            result.append(a)   #在list最后插入a            a,b=b,a+b        return result&gt;&gt;&gt;s=fib2(20)&gt;&gt;&gt;s[0,1,1,2,3,5,8,13]</code></pre><h3 id="定义默认参数值"><a href="#定义默认参数值" class="headerlink" title="定义默认参数值"></a>定义默认参数值</h3><p>　　给函数定义默认的参数值能够使用函数时更灵活地调用参数。比如：</p><pre><code>def ask_ok(pro,retries=4,reminder=&apos;please try again!&apos;):    while True:        ok=input(pro)        if ok in (&apos;y&apos;,&apos;ye&apos;,&apos;yes&apos;):            return True        if ok in (&apos;n&apos;,&apos;no&apos;,&apos;nop&apos;,&apos;nope&apos;):            return False        retries=retries-1        if retries&lt;0:            raise ValueError(&apos;invalid user response&apos;)        print(reminder)</code></pre><p>　　<br>  上面的定义的ask_ok函数后两个参数给定了默认值，因此下面三种方法都可以调用此函数。  </p><pre><code>ask_ok(&apos;Do you want to quit?&apos;) ask_ok(&apos;Ok to overwrite the file?&apos;,2)　　ask_ok(&apos;Ok to overwrite the file?&apos;,2,&apos;Go ahead,only &quot;yes&quot; or &quot;no&quot;&apos;)  </code></pre><p>　　　但是给定默认的初值的参数一定要在未给定默认值参数之后，否则当调用参数缺省时，编译器将会报故。</p><pre><code>&gt;&gt;&gt;def ask_ok( retries=4, reminder=&apos;Please try again!&apos;,prompt):     while True:         ok = prompt           if ok in (&apos;y&apos;, &apos;ye&apos;, &apos;yes&apos;):                return True        if ok in (&apos;n&apos;, &apos;no&apos;, &apos;nop&apos;, &apos;nope&apos;):                return False        retries = retries - 1        if retries &lt; 0:             raise ValueError(&apos;invalid user response&apos;)        print(reminder)  &gt;&gt;&gt;ask_ok(&apos;y&apos;) ....SyntaxError: non-default argument follows default argument</code></pre><p>　　默认的参数值会在函数被定义的时刻就被赋值，因此：</p><pre><code>i=5def f(arg=i):    print(arg)i=6f()5           #函数在定义时，参数被赋值为5</code></pre><p>　　<br>　　默认的参数值只会被赋值一次。当默认参数值为像list、字典（dictionary）或大多数类实例的可变对象时。例如，下面的函数在后续调用中累积传递给它的参数：</p><pre><code>def f(a,L=[]):    L.append(a)    return Lprint(f(1))print(f(2))print(f(3))</code></pre><p>　　结果将会打印出  </p><pre><code>[1][1, 2][1, 2, 3]</code></pre><p>　　如果不想在以后的调用中共享默认值，你可以像这样编写函数：</p><pre><code>def f(a,L=None):    if L is None:        L=[]    L.append(a)    return L  </code></pre><h3 id="关键字参数调用"><a href="#关键字参数调用" class="headerlink" title="关键字参数调用"></a>关键字参数调用</h3><p>　　函数还可以使用kwarg=value形式的关键字进行参数调用。比如下面函数：　　</p><pre><code>def parrot(voltage, state=&apos;a stiff&apos;, action=&apos;voom&apos;, type=&apos;Norwegian Blue&apos;):    print(&quot;-- This parrot wouldn&apos;t&quot;, action, end=&apos; &apos;)    print(&quot;if you put&quot;, voltage, &quot;volts through it.&quot;)    print(&quot;-- Lovely plumage, the&quot;, type)    print(&quot;-- It&apos;s&quot;, state, &quot;!&quot;)　　</code></pre><p>　　函数接收一个必要参数和三个可选参数。参数的调用可以使用下面任意方式：</p><pre><code>parrot(1000)                                         parrot(voltage=1000)                                 parrot(voltage=1000000, action=&apos;VOOOOOM&apos;)            parrot(action=&apos;VOOOOOM&apos;, voltage=1000000)             parrot(&apos;a million&apos;, &apos;bereft of life&apos;, &apos;jump&apos;)        parrot(&apos;a thousand&apos;, state=&apos;pushing up the daisies&apos;)  </code></pre><p>　　但是像下面的调用方式，编译器将会报错：</p><pre><code>parrot()                     # 缺少不可缺省参数parrot(voltage=5.0, &apos;dead&apos;)  # 不允许非关键字参数在关键字参数之后 parrot(110, voltage=220)     # 给一个参数重复提供初值parrot(actor=&apos;John Cleese&apos;)  # 不可知的参数（未定义的参数）  </code></pre><p>　　当最后一个参数是以<em>*name的形式出现,表示函数接收一个字典类型（dict）参数（带有关键字的形参）。形参还可以</em>name的形式出现，表示函数接收一个元组（tuple）类型的参数。但如果函数参数列表中既要定义字典类型又有元组类型，字典类型一定要放在元组类型参数之后。比如下面例子：  </p><pre><code>def cheeseshop(kind,*arguments,**keywords):    print(&quot;--Do you have any &quot;,kind,&quot;?&quot;)    print(&quot;--I&apos;m sorry,We&apos;re all out off&quot;,kind)    for arg in arguments:        print(arg)    print(&quot;-&quot;*40)    for kw in keywords:        print(kw,&quot;:&quot;,keywords[kw])</code></pre><p>　　可以像下面调用函数：</p><pre><code>cheeseshop(&quot;Limburger&quot;,&quot;It&apos;s very runny,sir.&quot;,               &quot;It&apos;s really very runny ,sir.&quot;,             shopkeeper=&quot;Michael&quot;,client=&quot;John&quot;,            sketch=&quot;Cheese shop Sketch&quot;)  </code></pre><p>　　结果显示如下：　　</p><pre><code>--Do you have any  Limburger ?　　　　　　　＃　kind--I&apos;m sorry,We&apos;re all out off Limburger   ＃　kindIt&apos;s very runny,sir.                      ＃　argumentsIt&apos;s really very runny ,sir.              ＃　arguments----------------------------------------shopkeeper : Michael                     #keywordsclient : John                             #keywordssketch : Cheese shop Sketch               #keywords  </code></pre><p>　　</p><h3 id="任意参数列表"><a href="#任意参数列表" class="headerlink" title="任意参数列表"></a>任意参数列表</h3><p>　　最常见的做法是指定一个函数可以用任意数量的参数调用。这些参数将被封装在一个元组中（参见Tuples和序列）。在变量数目可变之前，可能出现零个或多个正常参数。  </p><pre><code>def  write_multiple_items(file,separator,*args)    file.write(separator.join(args))  </code></pre><p>　　一般情况下，可变参数放在形参列表的最后，因为它将会接收所有它之后传递过来的参数。任意在*args参数后定义赋值的参数只能是关键字参数，而不能是位置参数。</p><pre><code>def concat(*args,sep=&quot;/&quot;):    return sep.join(args)  print(concat(&quot;earth&quot;,&quot;Mars&quot;,&quot;venus&quot;))earth/Mars/venus  </code></pre><h3 id="Lambda函数（匿名函数）"><a href="#Lambda函数（匿名函数）" class="headerlink" title="Lambda函数（匿名函数）　　"></a>Lambda函数（匿名函数）　　</h3><p>　　小型匿名函数可以通过声明lambda关键字进行构建。像lambda a,b:a+b这个函数以a，b为参数，返回a,b的和。Lambda函数可以在任意需要定义函数的地方使用。但它们在语法上被限制为单句表达。像嵌套函数定义一样，lambda函数也可以引用其作用域内的变量：</p><pre><code>def make_incrementor(n):    return lambda x: x + nf = make_incrementor(42)f(1)43</code></pre><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><ol><li>使用4个空格进行代码层次区分，而不要使用TAB；</li><li>一行不要超过79个字符；</li><li>使用空白行将函数、类或在函数中的较大的代码块区分开；</li><li>尽可能将注释与需注释的代码放在同一行；</li><li>使用docstrings对代码进行说明；</li><li>在操作符和逗号前后尽量空一格；</li><li>定义类和函数名时风格尽量保持一致；通常做法是定义类使用骆驼拼写风格（SampleCase），定义函数和方法时使用lower_case_with_underscores的拼写风格。类的第一个方法使用self作为参数；</li><li>不要使用奇怪的编码方式去写代码；在任何情况下，Python默认的UTF-8，或者纯ASCII都是最好的编码方式；</li><li>同样地，如果使用不同语言的人阅读或维护代码的机会很小，请不要在标识符中使用非ASCII字符。</li></ol><p>#数据结构  </p><h3 id="list用作堆栈"><a href="#list用作堆栈" class="headerlink" title="list用作堆栈"></a>list用作堆栈</h3><p>　　列表方法使得使用列表作为堆栈（先进后出）非常容易。在堆栈顶部添加一个元素，可以使用append()。使用不带参数的pop()函数在堆栈顶部取出一个元素。比如：  </p><pre><code>&gt;&gt;&gt;stack=[3,4,5]&gt;&gt;&gt;stack.append(6)&gt;&gt;&gt;stack[3,4,5,6]&gt;&gt;&gt;stack.pop()6  </code></pre><h3 id="list用作队列"><a href="#list用作队列" class="headerlink" title="list用作队列"></a>list用作队列</h3><p>　　列表也可以被用作队列（先入先出），但列表用作队列并不方便。因为从队列底部插入和取出元素都很快，从队列头部很慢。<br>　　为实现一个队列，使用collections.deque,collections.deque能够实现列表两端的插入元素和取出元素。比如：  </p><pre><code>&gt;&gt;&gt;from collections import deque&gt;&gt;&gt;queue=deque([1,2,2,3,4])&gt;&gt;&gt;queue.append(&quot;mark&quot;)&gt;&gt;&gt;queue.popleft()1&gt;&gt;&gt;queue.popleft()2&gt;&gt;&gt;queuedeque([2,3,4,‘mark’])</code></pre><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>　　列表推导式提供了一个简洁的创建列表的方式。通常构建新列表元素的方法使根据一个序列或迭代器经过一些操作形成另一对应的结果，或满足特定条件下筛选出的子序列。比如：  </p><pre><code>&gt;&gt;&gt;s=[]&gt;&gt;&gt;for x in range(10):        s.append(x**3)&gt;&gt;&gt;s[0,1,8,27,64,125,216,343,512,729]</code></pre><p>　　也可以使用匿名函数形成列表：</p><pre><code>&gt;&gt;&gt;s=list(map(lambda x:x**2,range(5)))&gt;&gt;&gt;s[0,1,4,9,16]  </code></pre><p>　　也可以使用等式：  </p><pre><code>s=[x**2 for x in range(10)]&gt;&gt;&gt;[(x,y) for x in [1,2,3] for y in [3,1,4] if x!=y][(1,3),(1,4),(2,3),(2,1),(2,4),(3,1),(3,4)]  </code></pre><p>###嵌套列表推导式　　<br>　　　列表推导式的初始表达可以是任意的表达式，包括另一个列表推导式。例如下面的一个3*4的矩阵，它由一个内嵌3个长度为4的列表的列表形成：  </p><pre><code>&gt;&gt;&gt;matrix=[[1, 2, 3, 4],          [5, 6, 7, 8],          [9, 10, 11, 12]]  </code></pre><p>　　下面是转置该矩阵的列表推导式：</p><pre><code>&gt;&gt;&gt;[[row[i] for row in matrix] for i in range(4)][[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]  </code></pre><p>　　内嵌的列表推导式根据后面的for语句表达的顺序进行求值，因此上述推导式等价于：  </p><pre><code>&gt;&gt;&gt; transposed = []&gt;&gt;&gt; for i in range(4):  ...     transposed.append([row[i] for row in matrix])  ...&gt;&gt;&gt; transposed    [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]    </code></pre><p>　　进一步解析，等价于：</p><pre><code>&gt;&gt;&gt; transposed = []&gt;&gt;&gt; for i in range(4):...     transposed_row = []...     for row in matrix:...         transposed_row.append(row[i])...     transposed.append(transposed_row)...&gt;&gt;&gt; transposed[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]  </code></pre><p>　　也许在实际应用中，我们更喜欢用内置函数来实现复杂的表达式。zip（）函数可以很好的完成上述矩阵的转置：  </p><pre><code>&gt;&gt;&gt;list(zip(*matrix))[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]  </code></pre><h2 id="del表达式"><a href="#del表达式" class="headerlink" title="del表达式"></a>del表达式</h2><p>　　　del表达式可以根据列表的下标删除列表中的元素。这不同于pop()函数，pop()函数会返回元素的值，del不会。del表达式也可以使用切片删除列表中的多个元素，甚至删除整个列表。比如：</p><pre><code>&gt;&gt;&gt;a=[1,2,3,4,5,6]&gt;&gt;&gt;del a[0]&gt;&gt;&gt;a[2,3,4,5,6]&gt;&gt;&gt;del a[2:4]&gt;&gt;&gt;a[2,5,6]&gt;&gt;&gt;del a&gt;&gt;&gt;a........NameError: name &apos;a&apos; is not defined  </code></pre><h2 id="Tuples和序列"><a href="#Tuples和序列" class="headerlink" title="Tuples和序列"></a>Tuples和序列</h2><p>　　像list和string都是序列数据类型，它们有很多共同的特点，比如可以有下标，可以进行切片操作。Python语言中还存在另一种标准的序列数据类型：tuple。<br>　　定义tuple，tuple各元素之间用逗号隔开，比如：</p><pre><code>&gt;&gt;&gt;t=123,456,&apos;hi&apos;&gt;&gt;&gt;t(123,456,&apos;hi&apos;)&gt;&gt;&gt;t=(123,456,&apos;hi&apos;)  #定义tuple更标准的形式 &gt;&gt;&gt;t=tuple((123,456,&apos;hi&apos;)) #函数形式定义 &gt;&gt;&gt;u=t,(1,2,3,4)     #tuple还可以嵌套&gt;&gt;&gt;u((123,456,&apos;hi&apos;),(1,2,3,4))&gt;&gt;&gt;t[0]=0            #tuple是不可变序列Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;tuple&apos; object does not support item assignment&gt;&gt;&gt;v=([1,2,3],[3,2,1])   #tuple的元素可以是可变序列list&gt;&gt;&gt;v([1,2,3],[3,2,1])</code></pre><p>　　定义一些特殊的tuple类型对象，需要注意一些问题：</p><pre><code>&gt;&gt;&gt;empty=() #0个元素的tuple类型，一定要用括号&gt;&gt;&gt;m=&apos;hello&apos;, #定义一个元素的tuple类型，后面一定要加逗号 &gt;&gt;&gt;x,y,z=t&gt;&gt;&gt;x123&gt;&gt;&gt;y456&gt;&gt;&gt;z&apos;hi&apos;&gt;&gt;&gt;a,b=t......ValueError:not enough values to unpack(expected 2,got 1)  </code></pre><h2 id="集合（sets）"><a href="#集合（sets）" class="headerlink" title="集合（sets）"></a>集合（sets）</h2><p>　　set是一个无重复元素的无序合集。和数学中的概念一样，set也有并集、合集、差集等运算。</p><pre><code>&gt;&gt;&gt;basket={&apos;apple&apos;,&quot;orange&quot;,&apos;apple&apos;,&apos;pear&apos;,&apos;orange&apos;,&apos;banana&apos;}&gt;&gt;&gt;basket{&apos;orange&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;apple&apos;}  #自动删除重复元素&gt;&gt;&gt;basket=set((&apos;apple&apos;,&quot;orange&quot;,&apos;apple&apos;,&apos;pear&apos;,&apos;orange&apos;,&apos;banana&apos;))  #函数形式创建set&gt;&gt;&gt;&apos;orange&apos; in basket    True....&gt;&gt;&gt;a={&apos;qw&apos;,&apos;r&apos;}&gt;&gt;&gt;b={&apos;qw&apos;,&apos;m&apos;}&gt;&gt;&gt;a-b        #a,b的差集，只在a中元素的集合{&apos;r&apos;}&gt;&gt;&gt;a|b        #a,b的合集，在a或者在b中的元素的集合{&apos;m&apos;,&apos;qw&apos;,&apos;r&apos;}&gt;&gt;&gt;a&amp;b        #a,b的并集，同时在a,b中元素的集合{&apos;qw&apos;}&gt;&gt;&gt;a^b        #a，b集合的异或，在a或者b中，但不在a,b的并集中元素的集合{&apos;m&apos;,&apos;r&apos;}  </code></pre><p>　　同样，像list推导式，set推导式也是被支持的：</p><pre><code>&gt;&gt;&gt;a={x for x in &quot;abracadabra&quot; if x not in &apos;abc&apos;}&gt;&gt;&gt;a{&apos;r&apos;,&apos;a&apos;}  </code></pre><h2 id="字典（dict）"><a href="#字典（dict）" class="headerlink" title="字典（dict）"></a>字典（dict）</h2><p>　　dict（字典）是Python语言中一种很有用的数据类型。在其他语言中dict被称为关联内存或关联数组。不同于序列由一列数字索引，字典由关键字索引，关键字可以是任意的非变类型；所有字符串和数字都可以作为字典的关键字。tuple类型只有当其元素不含可变类型数据时可以作为关键字。list类型不能被用作字典的关键字。<br>　　理解字典类型，最好将它看成一个无序的key:value组的集合，在一个字典里，每个关键字是唯一的。一对花括号创建一个空的字典：{}。每个key:value对之间用逗号隔开。  </p><pre><code>&gt;&gt;&gt;tel={&apos;jack&apos;: 4098, &apos;sape&apos;: 4139,&apos;jack&apos;:3022}&gt;&gt;&gt;tel{&apos;jack&apos;:3022,&apos;sape&apos;: 4139}      #重复的关键字会保留最后一组key:value对，其他自动删除。&gt;&gt;&gt;tel[&apos;lili&apos;]=4423              #增加字典元素&gt;&gt;&gt;tel{&apos;jack&apos;:3022,&apos;sape&apos;: 4139,&apos;lili&apos;:4423}&gt;&gt;&gt;del tel[&apos;sape&apos;]&gt;&gt;&gt;tel{&apos;jack&apos;:3022,&apos;lili&apos;:4423}&gt;&gt;&gt;list(tel.keys())[&apos;jack&apos;,&apos;lili&apos;]&gt;&gt;&gt;sorted(tel.keys())[&apos;jack&apos;,&apos;lili&apos;]&gt;&gt;&gt;sorted(tel.values())[3022,4423]&gt;&gt;&gt;&apos;jack&apos; in telTrue</code></pre><p>　　dict()直接根据key-value序列创建字典：  </p><pre><code>&gt;&gt;&gt; dict([(&apos;sape&apos;, 4139), (&apos;guido&apos;, 4127), (&apos;jack&apos;, 4098)]){&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127}  </code></pre><p>　　字典推导式可以根据任意的关键字和值创建字典：  </p><pre><code>&gt;&gt;&gt;{x:x**2 for x in(1,2,3)}{1:1,2:4,3:9}  </code></pre><p>　　当关键字只为字符串，可以简化字典类型的创建：  </p><pre><code>&gt;&gt;&gt;dict(sape=4139, guido=4127, jack=4098){&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127}</code></pre><h2 id="循环技巧"><a href="#循环技巧" class="headerlink" title="循环技巧"></a>循环技巧</h2><p>　　当遍历字典时，关键字和相关的值可以通过items()方法同时提取。</p><pre><code>&gt;&gt;&gt; knights = {&apos;gallahad&apos;: &apos;the pure&apos;, &apos;robin&apos;: &apos;the brave&apos;}&gt;&gt;&gt; for k, v in knights.items():...     print(k, v)...gallahad the purerobin the brave  </code></pre><p>　　当遍历一个序列时，元素的位置和值可以通过enumerate()函数同时获取。  </p><pre><code>&gt;&gt;&gt; for i, v in enumerate([&apos;tic&apos;, &apos;tac&apos;, &apos;toe&apos;]):...     print(i, v)...0 tic1 tac2 toe  </code></pre><p>　　同时遍历两个序列，可以使用zip()函数：                 </p><pre><code>&gt;&gt;&gt; questions = [&apos;name&apos;, &apos;quest&apos;, &apos;favorite color&apos;]&gt;&gt;&gt; answers = [&apos;lancelot&apos;, &apos;the holy grail&apos;, &apos;blue&apos;]&gt;&gt;&gt; for q, a in zip(questions, answers):...     print(&apos;What is your {0}?  It is {1}.&apos;.format(q, a))...What is your name?  It is lancelot.What is your quest?  It is the holy grail.What is your favorite color?  It is blue.  </code></pre><p>　　反序遍历序列，调用reversed()函数，排序使用sorted()函数：</p><pre><code>&gt;&gt;&gt; for i in reversed(range(1, 10, 2)):   #resversed()返回的是一个迭代器类，而不是反序后的序列。...     print(i)...97531  </code></pre><p>　　有时候想在遍历序列的时候改变它，简单而又安全的方法是将新建一个序列。</p><pre><code>&gt;&gt;&gt; import math&gt;&gt;&gt; raw_data = [56.2, float(&apos;NaN&apos;), 51.7, 55.3, 52.5, float(&apos;NaN&apos;), 47.8]&gt;&gt;&gt; filtered_data = []&gt;&gt;&gt; for value in raw_data:...     if not math.isnan(value):...         filtered_data.append(value)...&gt;&gt;&gt; filtered_data[56.2, 51.7, 55.3, 52.5, 47.8]  </code></pre><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>　　如果退出了Python解释器并再次进入它，那之前的定义（函数或变量）都会丢失。因此，如果想编写更长的程序，最好使用一个文件编辑器去编写输入文件，使用解释器去运行这个文件，而不是直接在解释器中直接输入运行。这也就是所谓的编写脚本。当程序很长时，为了更易于维护，可能需要把它分成几个文件。当在多个程序中用到一个共同的函数时，你肯定也不希望在每个程序中重复地把这个函数再编写一遍。<br>　　为了满足上述情况，Python的方法是将定义放入文件并在脚本中或解释器的交互实例中使用它们。这些文件被称为模块；模块中的定义可以被其他模块或主模块（在顶层或计算器模式下执行的脚本中可以访问变量的集合）导入。<br>　　模块是一个包含Python定义和语句的文件。文件名就是模块名带.py后缀。在模块内部，模块的名字可以由全局变量<strong>name</strong>访问。用文本编辑器编写下列内容，并把文件命名为fibo.py保存在解释器运行目录下:</p><pre><code># Fibonacci numbers moduledef fib(n):    # write Fibonacci series up to n    a, b = 0, 1    while b &lt; n:        print(b, end=&apos; &apos;)        a, b = b, a+b    print()def fib2(n):   # return Fibonacci series up to n    result = []    a, b = 0, 1    while b &lt; n:        result.append(b)        a, b = b, a+b    return result    </code></pre><p>　　在解释器中输入导入该模块的命令：  </p><pre><code>&gt;&gt;&gt; import fibo</code></pre><p>　　此时的符号列表中没有fibo模块中定义的函数名；只用fibo在那。可以通过模块名进入模块中的函数：  </p><pre><code>&gt;&gt;&gt; fibo.fib(1000)1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987&gt;&gt;&gt; fibo.fib2(100)[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]&gt;&gt;&gt; fibo.__name__&apos;fibo&apos;</code></pre><h2 id="模块深入"><a href="#模块深入" class="headerlink" title="模块深入"></a>模块深入</h2><p>　　一个模块内可以包含任意像函数声明的可执行语句。    这些可执行声明只有在第一次遇到一个import声明时被执行。（或者当文件被当做一个脚本时，也可以直接执行）<br>　　每一个模块会有它各自的符号列表，这个符号列表会被作为模块中所有函数的全局符号类表。因此，因此，模块的作者可以在模块中使用全局变量，而不必担心与用户的全局变量发生意外冲突。另一方面，如果你知道你正在干什么，你可以直接以函数相同的符号（modname.item的形式）来触及模块的全局变量。<br>　　模块可以引用其他模块。一般会把模块所有的引用在模块开头就用import语句进行声明，但这并不是必须的。引用过的模块名也会被引入到模块的全局符号列表。　　<br>　　有很多直接引用模块的import声明形式。比如：</p><pre><code>&gt;&gt;&gt; from fibo import fib, fib2&gt;&gt;&gt; fib(500)1 1 2 3 5 8 13 21 34 55 89 144 233 377</code></pre><p>　　<br>　　但例子中的引入方式并没有将模块名（fibo）引入到本地符号列表中，也就是说上面例子中，fibo是没有被定义的。可以直接引用模块中所有的定义。</p><pre><code>&gt;&gt;&gt; from fibo import *&gt;&gt;&gt; fib(500)1 1 2 3 5 8 13 21 34 55 89 144 233 377    </code></pre><p>　　其他引用模块的形式：　　</p><pre><code>&gt;&gt;&gt; import fibo as fib&gt;&gt;&gt; fib.fib(500)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377　  </code></pre><h3 id="把模块当做脚本执行"><a href="#把模块当做脚本执行" class="headerlink" title="把模块当做脚本执行"></a>把模块当做脚本执行</h3><p>　　当用下面的语句运行Python模块时：  </p><pre><code>python fibo.py &lt;arguments&gt;  </code></pre><p>模块将会被执行，就像你把<strong>name</strong>设置为“<strong>main</strong>”时引用这个模块一样。  </p><pre><code>if __name__ == &quot;__main__&quot;:     import sys     fib(int(sys.argv[1]))  </code></pre><p>　　<br>如果你不加入上述代码，模块将不会像脚本一样运行，因为代码的解析只有当遇到“main”文件时才会被执行。  </p><h3 id="模块的查找路径"><a href="#模块的查找路径" class="headerlink" title="模块的查找路径"></a>模块的查找路径</h3><p>　　当一个名为spam的模块被导入时，解释器首先会查找内置模块中的spam。如果没有找到，那它就会根据所给的sys.path路径查找spam.py文件。sys.path可以是下面的路径形式：</p><p>　　　　</p><ol><li>包含所引入脚本的文件夹（若当下解析器的运行文件夹正式引用模块的所在文件夹，文件路径可以不必特殊说明）  　　　</li><li>　PYTHONPATH(一串和shell中PATH变量语法相同的文件名)  　</li><li>安装默认的依赖文件路径  </li></ol><p>　　当初始化之后，Python程序可以更改sys.path。因为包含脚本文件夹初始化sys.path的优先级是最高的，因此当引用的模块在包含的脚本文件夹中，同时有个相同名字的模块在标准模块库中时，解析器导入的时文件夹中的模块。  </p><h3 id="“编译”Python文件"><a href="#“编译”Python文件" class="headerlink" title="“编译”Python文件"></a>“编译”Python文件</h3><p>　　为了加速加载模块，Python将会把每个模块编译的版本缓存在__pycache__文件下module.version.pyc文件里，这个文件也就是该版本下的Python对编译文件进行编码的地方；它一般会包含Python的版本号。比如，在CPython3.3发布版中编译spam.py的文件将会被缓存为__pycache__/spam.cpython-33.pyc。这种命名的转换允许各种版本Python编译的模块共存。<br>　　Python会检查源代码的修改日期与编译后的版本，以查看是否过期，是否需要重新编译。这完全是一个自动进行的过程。并且，编译过的模块是不依赖于平台的，因此同样的库可以在不同架构的系统中共享。<br>　　Python会在两种情况下检查缓存。首先，它总是重新编译，并且不存储直接从命令行加载的模块的结果。其次，如果没有源模块，它将不会检查缓存。为了支持非源代码（仅编译的）的分发，编译后的模块必须位于源目录中，并且不能有一个源模块。  </p><p>TIPS:  </p><ol><li>可以用Python命令中加入-O或-OO去减小编译模块的大小。-O转换会删除源码中的断言语句，-OO转换会删除源码中的断言语句和__doc__字符串。  </li><li>当程序运行.pyc文件并不会比.py文件速度快。而是加载.pyc文件比.py文件快。  </li><li>compileall模块可以为一个文件夹下的所有模块穿件一个.pyc文件。  </li></ol><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>　　Python自带了一个标准模块的库。有些模块被内置到解释器里，这些模块提供对不属于语言核心部分的操作的访问，但它们是内置的，这对于无论是为了提高效率，还是提供对操作系统原语（如系统调用）的访问都是必需的。这些模块的集合也是有配置要求的，它也依赖于底层平台。比如，winreg模块只能用于Windows系统。一个值得注意的特殊模块是sys模块，它被内置在任意平台的Python解释器中。变量sys.path决定了解释器查找模块的路径。它默认由系统环境中PYTHONPATH变量初始化，或者在PYTHONPATH未被设置的情况下由一个默认的内置值初始化。可以使用标准列表操作更改它：</p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(&apos;/ufs/guido/lib/python&apos;)  </code></pre><h2 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a>dir()函数</h2><p>　　内置函数dir()被用于模块定义的名字，它返回一系列字符串。  </p><pre><code>&gt;&gt;&gt;import fibo,sys    &gt;&gt;&gt;dir(fibo)      [&apos;__builtins__&apos;,&apos;__cached__&apos;,&apos;__doc__&apos;,&apos;__file__&apos;,&apos;__l    oader__&apos;,&apos;__name__&apos;,&apos;__package__&apos;,&apos;__spec__&apos;,&apos;fib&apos;,&apos;fib2&apos;]&gt;&gt;&gt;import fibo,sys</code></pre><p>　　如果不带参数，dir()返回当前所定义的名字：  </p><pre><code>&gt;&gt;&gt;a=[1,2,3]&gt;&gt;&gt;import fibo&gt;&gt;&gt;fib=fibo.fib&gt;&gt;&gt;dir() [&apos;__annotations__&apos;,&apos;__builtins__&apos;,&apos;__doc__&apos;,&apos;__l    oader__&apos;,&apos;__name__&apos;,&apos;__package__&apos;,&apos;__spec__&apos;,&apos;a&apos;,&apos;fib&apos;,&apos;fibo&apos;]    </code></pre><p>　　dir()返回所有形式的命名：变量，模块，函数等等，但它不会列出内置函数和变量的命名。内置函数和变量被定义在builtins模块中，使用dir(builtins)可以返回所有内置函数和变量的名字。  </p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>　　包是通过使用“点号模块名”来构造Python的模块名称空间的一种方式。例如，模块名A.B就是包在命名为A中的B模块。就像使用不同模块的中的相同名字不必担心彼此的全局变量名称一样,点号模块名称也使得使用者不必担心不同包如NumPy或Python的图像库中相同的模块产生混淆。<br>　　想象一下，如果你想设计一个统一处理声音文件和声音数据的模块集合（包）。声音文件有很多种格式（一般以不同的扩展名区分，比如.wav,.aiff），因此你需要不断更新和增加模块去维持各文件格式之间的转换。声音数据也可能需要很多种不同的操作（比如混音，增加回响，提供平衡器功能，创建人工音响效果），因此你将会编写一个无尽头的模块库去实现这些操作。下面是你所涉及的包可能呈现的结构方式：  </p><pre><code>sound/                          Top-level package    __init__.py               Initialize the sound package    formats/                  Subpackage for file format conversions          __init__.py          wavread.py          wavwrite.py          aiffread.py          aiffwrite.py          auread.py          auwrite.py          ...     effects/                  Subpackage for sound effects          __init__.py          echo.py          surround.py          reverse.py          ...     filters/                  Subpackage for filters          __init__.py          equalizer.py          vocoder.py          karaoke.py          ...</code></pre><p>　　当导入这个包时，Python会在sys.path定义的路径中查找包的子文件夹。<br>　　__init__.py使Python将文件夹当做封闭包结构；这种做法防止了在后面查询模块名时，无意中包名和模块名相同时的冲突。最简单的情况下，__init__.py可以只是一个空文件，当然它也可以执行包的初始化代码或者设置__all__变量。<br>　　用户可以从包中导入自己定义的模块，比如：  </p><pre><code>import sound.effects.echo </code></pre><p> 　　这会载入sound.effects.echo子模块。但使用模块中的函数时，一定要使用全名：  </p><pre><code>sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)    </code></pre><p>　　 另一种导入子模块的方法是：  </p><pre><code>from sound.effects import echo </code></pre><p>　　 这也会载入echo子模块，但使用模块中的函数时，它可以不需要包名作为前缀：  </p><pre><code>echo.echofilter(input, output, delay=0.7, atten=4)  </code></pre><p>　　<br>    当然也可以直接导入函数或变量：  </p><pre><code>from sound.effects.echo import echofilter  </code></pre><p>　　　使用这种方法加载echo子模块，那么可以直接使用它的函数：  </p><pre><code>echofilter(input,output,delay=0.7,atten=4)  </code></pre><p>　　 当使用from package import item的形式，item可以是包中的一个子模块，也可以是包中其他任意的名字（像类名、函数名、变量名等）。import声明首先会检测item是否被定义在包内，如果不是，它会假设item是一个模块并试图加载它。如果在包中没有找到item，就会报出ImportError异常。　　<br>　　相反，当使用像import item.subitem.subsubitem的形式，除了最后一个item可以不是包，其他都必须是包名；最后一个item可以是一个模块或包但不可以是前面一个item中定义的类、函数或变量。  </p><h3 id="从包中import"><a href="#从包中import" class="headerlink" title="从包中import *"></a>从包中import *</h3><p>　　当使用form sound.effects import <em>会发生什么？理想情况下，用户可能希望这种方法可以以某种方法进入文件系统，找出包中的子模块，并将它们全部导入。这可能会花费很长时间而且导入子模块会产生意想不到的副作用（当然只有在子模块被显式导入时，这种副作用才会产生）。<br>　　唯一解决的方法是包的作者提供包的显式目录。import的声明会使用下列约束：如果包中__init__.py代码定义了一个名为__all__的列表时，那这个列表将会被作为from package import </em>导入的模块名列表。它要求包的作者在包版本更新时也及时更新该列表。比如：sound/effects/__init__.py中可以包含如下代码：  </p><pre><code>__all__=[&apos;echo&apos;,&apos;surround&apos;,&apos;reverse&apos;] </code></pre><p>　　这意味着from sound.effects import <em>将会从包中加载这三个子模块。<br>　　如果没有定义__all__，from sound.effects import </em>声明不会将sound.effects包中的任意子模块名导入到当前的命名空间；它只会在确定sound.effects包名已经被导入后再导入包中定义的名称。这些名称包含__init__.py中定义的任意名称和任意在前面已经通过import声明显式导入的包中的子模块名。考虑下列代码：  </p><pre><code>import sound.effects.echoimport sound.effects.surroundfrom sound.effects import *</code></pre><p>　　这个例子中，当执行from……import声明时，echo和surround模块也会被导入到当前命名空间，因为它们已经被显式导入。<br>　　虽然当使用import *时，特定的模块被设计成遵循特定的方式只输出名称，但在生产代码时，这还是被认为糟糕的做法。<br>　　使用from Package import specific_submodule的方式将永远是正确的。实际上，这是推荐的表示方法，除非需要导入模块来自不同包的同名子模块。  </p><h1 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h1><p>　　程序的输出可以有多种呈现方式，数据可以打印成可读方式 ，或者写入一个文件供以后使用。这章将会探讨可能的输出方式。 　　</p><h2 id="设计输出格式"><a href="#设计输出格式" class="headerlink" title="设计输出格式"></a>设计输出格式</h2><p>　  　到目前为止，我们遇到了两种写值的方式：表达式语句和print（）函数。（第三种方法是使用文件对象的write()方法；标准输出文件可以被引用为sys.stdout。）<br>　　经常你会希望更多方式的控制输出的格式，而不是仅仅打印用空格分开的值。有两种方法去格式化你的输出；第一种方法是所有的字符串自己处理；使用字符串切片和连接操作，你可以创建任何你可以想到的布局。字符串类型有一些方法可以很好的将字符串填入一个给定列宽度的空间。第二种方法是是使用格式化的字符串，或者能够使用str.format()的方法。<br>　　字符串模块包含一个模板类，这个类提供另一种把值转换成字符串的方法。<br>　　那如何把其他类型值转换成字符串呢？Python中可以通过repr()或者str()函数将它转换成字符串。<br>　　str（）函数的目的是返回可读的值，但是repr()函数的目的是返回解释器可以读懂的值。许多类型像数字或结构像列表和字典的值，使用repr()和str()函数，返回的值是一样的。特殊情况是字符串，两个函数转换字符串返回的值有所不同。  </p><pre><code>&gt;&gt;&gt; s = &apos;Hello, world.&apos;&gt;&gt;&gt; str(s)&apos;Hello, world.&apos;&gt;&gt;&gt; repr(s)&quot;&apos;Hello, world.&apos;&quot;&gt;&gt;&gt; str(1/7)&apos;0.14285714285714285&apos;&gt;&gt;&gt; x = 10 * 3.25&gt;&gt;&gt; y = 200 * 200&gt;&gt;&gt; s = &apos;The value of x is &apos; + repr(x) + &apos;, and y is &apos; + repr(y) + &apos;...&apos;&gt;&gt;&gt; print(s)The value of x is 32.5, and y is 40000...&gt;&gt;&gt; # The repr() of a string adds string quotes and backslashes:... hello = &apos;hello, world\n&apos;&gt;&gt;&gt; hellos = repr(hello)&gt;&gt;&gt; print(hellos)&apos;hello, world\n&apos;&gt;&gt;&gt; # The argument to repr() may be any Python object:... repr((x, y, (&apos;spam&apos;, &apos;eggs&apos;)))&quot;(32.5, 40000, (&apos;spam&apos;, &apos;eggs&apos;))&quot;　　</code></pre><p>　　下面是打印数字平方和立方阵列的两种方法：  </p><pre><code>&gt;&gt;&gt; for x in range(1, 11):...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=&apos; &apos;)...     # Note use of &apos;end&apos; on previous line...     print(repr(x*x*x).rjust(4))...1   1    12   4    83   9   274  16   645  25  1256  36  2167  49  3438  64  5129  81  72910 100 1000  &gt;&gt;&gt; for x in range(1, 11):...     print(&apos;{0:2d} {1:3d} {2:4d}&apos;.format(x, x*x, x*x*x))...1   1    12   4    83   9   274  16   645  25  1256  36  2167  49  3438  64  5129  81  72910 100 1000  </code></pre><p>　　输出格式的排版，第一个例子使用了str.rjust()函数，即字符串右对齐。还有其他几个相似的函数如str.ljust()(左对齐)、str.center()(居中)。这些函数都不会写入任何东西，只是返回一个新的字符串。如果输入的字符串太长，它们也不会截断字符串，而是直接不加改变返回原字符串。如果想截断字符串可以加一个切片操作，如in x.ljust(n)[:n]。　　<br>　　还有另外一个函数str.fill()，它可以在数字型字符串左边添加0.它可以理解加法和减法运算符：  </p><pre><code>&gt;&gt;&gt; &apos;12&apos;.zfill(5)&apos;00012&apos;&gt;&gt;&gt; &apos;-3.14&apos;.zfill(7)&apos;-003.14&apos;&gt;&gt;&gt; &apos;3.14159265359&apos;.zfill(5)&apos;3.14159265359&apos;  </code></pre><p>　　str.format()函数的基本用法如下：  </p><pre><code>&gt;&gt;&gt;    print(&apos;Who is the {} who say &quot;{}!&quot;&apos;.format(&apos;boy&apos;,&apos;Wonderful&apos;))Who    is the boy who say &quot;Wonderful!&quot;  </code></pre><p>　　花括号以及括号内的字符（被称为格式域）被str.format()函数传递的对象所取代。花括号中的数值可以用作str.format()函数对象替代的位置。  </p><pre><code>&gt;&gt;&gt; print(&apos;{0} and {1}&apos;.format(&apos;spam&apos;, &apos;eggs&apos;))spam and eggs&gt;&gt;&gt; print(&apos;{1} and {0}&apos;.format(&apos;spam&apos;, &apos;eggs&apos;))eggs and spam  </code></pre><p>　　如果在str.format()函数中使用关键字参数，它们的值将会被关键字参数对应的值代替。  </p><pre><code>&gt;&gt;&gt; print(&apos;This {food} is {adjective}.&apos;.format(...       food=&apos;spam&apos;, adjective=&apos;absolutely horrible&apos;))   #若在花括号中使用了关键字，而format()函数没有对应的关键字，解释器将会报关键字错误。This spam is absolutely horrible.  </code></pre><p>　　位置和关键字参数可以任意组合。  </p><pre><code>&gt;&gt;&gt; print(&apos;The story of {0}, {1}, and {other}.&apos;.format(&apos;Bill&apos;, &apos;Manfred&apos;,                                               other=&apos;Georg&apos;))The story of Bill, Manfred, and Georg.  </code></pre><p>　　‘!a’(应用于ascii()),’!s’（应用于str()）和’!r’（应用于repr()）可以在格式化之前进行格式转换：  </p><pre><code>&gt;&gt;&gt; contents = &apos;eels&apos;&gt;&gt;&gt; print(&apos;My hovercraft is full of {}.&apos;.format(contents))My hovercraft is full of eels.&gt;&gt;&gt; print(&apos;My hovercraft is full of {!r}.&apos;.format(contents))My hovercraft is full of &apos;eels&apos;.  </code></pre><p>　　一个可选的“：”和格式说明符可以跟随字段名。这允许更全面的控制值的格式。下面是保留Pi小数点后三位数的例子：  </p><pre><code>&gt;&gt;&gt;import math&gt;&gt;&gt;print(&apos;The balue of PI is approximately {0:.3f}.&apos;.format(math.pi))The value of PI is approximately 3.142.  </code></pre><p>　　在’：’后面跟一个数字将会使格式域的长度为最小数字个字符的长度。这可以被用于排版表格。  </p><pre><code>&gt;&gt;&gt;table={&quot;Jack&quot;:123,&quot;Jone&quot;:234}&gt;&gt;&gt;for a,b in table.items():        print(&apos;{0:10} {1:10d}&apos;.format(a,b))Jack              123Jone              234  </code></pre><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>　　%操作可以用于字符串的格式化。比如：  </p><pre><code>&gt;&gt;&gt; import math&gt;&gt;&gt; print(&apos;The value of PI is approximately %5.3f.&apos; % math.pi)The value of PI is approximately 3.142.  </code></pre><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>　　open()函数返回一个文件对象，它通常使用两个参数：open(filename,mode)。  </p><pre><code>&gt;&gt;&gt;f=open(&apos;workfile&apos;,&apos;w&apos;)   </code></pre><p>　　  第一个参数是包含文件名的字符串；第二个参数为读写模式的指代字符。当文件已只读方式打开时，模式可以是’r’；’w’为只写模式（相同名字的已存在的文件将会被擦写掉）;’a’为打开附加模式,任何被写入的数据都会自动添加在文件最后。’r+’同时以读和写两种方式打开文件。模式参数可以缺省，但缺省情况下默认为’r’模式。<br>　　一般情况下，文件是以文本格式打开，也就是，从文件中读写的字符串需要指定编码格式。如果未指定编码格式，默认情况下由运行系统决定。’b’为以二进制模式打开文件；二进制模式可以应用于任何不包含文本格式的文件。<br>　　在文本格式下，当读文件时，默认会地将每行的结尾（在Unix系统中是\n，Window系统中是\r\n）转换为\n。当以文本格式进行写操作时，默认情况下会把换行符\n转换成系统默认的换行符。这种对文件数据的幕后修改对于文本文件来说是没问题的，但是会在像JPEG或EXE的文件中损坏二进制数据。在读写这样的文件时要非常小心使用二进制模式。<br>　　当处理文件系统时，使用with关键字将是一个很好的习惯。这样做的好处是，即使在某个点上出现了异常，文件也会在其操作结束后被正确关闭。使用with也比编写相同的try-finally块要短得多：</p><pre><code>&gt;&gt;&gt; with open(&apos;workfile&apos;) as f:...     read_data = f.read()&gt;&gt;&gt; f.closedTrue  </code></pre><p>　　如果没有使用with关键字，那么就需要调用f.close()函数去关闭文件并立即释放任何被它使用的系统资源。如果不显式地关闭文件，Python的垃圾回收机制将最终会销毁对象并关闭文件，但文件不会立即被关闭，而会持续一段时间。另一个风险是不同的Python任务会在不同的时间清理这些打开的文件。<br>　　当一个文件对象关闭后，无论是使用with关键字还是通过调用f.close()，将无法再使用这个文件对象。  </p><pre><code>&gt;&gt;&gt; f.close()&gt;&gt;&gt; f.read()Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: I/O operation on closed file  </code></pre><h3 id="文件对象的方法"><a href="#文件对象的方法" class="headerlink" title="文件对象的方法"></a>文件对象的方法</h3><p>　　以下例子均设想一个称为f的文件对象已经被建立。<br>　　读取文件内容，调用f.read(size),这个函数读取一些数据并将它们返回成字符（在文本模式下）或二进制对象（在二进制模式下），size是一个可选参数。当size缺省或为负数时，文件中的整个内容将会会被读取和返回。如果文件的结尾已经到达了，f.read()将会返回一个空的字符串（’’）。  </p><pre><code>&gt;&gt;&gt; f.read()&apos;This is the entire file.\n&apos;&gt;&gt;&gt; f.read()&apos;&apos;  </code></pre><p>　　f.readline()读取文件中的单独一行； 新行的换行字符会留在字符串的末尾，而且只有文件的最后一行会缺省换行字符（如果文件没有以换行符结束）。这使得函数返回的值清晰明确；如果f.readline()返回一个空字符串，说明读取到文件的结尾，当一个空行由’\n’表示时，一个字符串只包含一行。  </p><pre><code>&gt;&gt;&gt; f.readline()&apos;This is the first line of the file.\n&apos;&gt;&gt;&gt; f.readline()&apos;Second line of the file\n&apos;&gt;&gt;&gt; f.readline()&apos;&apos;  </code></pre><p>　　<br>　　对于一行一行的从文件中读取，可以对整个文件对象进行循环操作。这种操作节省内存、快，而且代码简洁：  </p><pre><code>&gt;&gt;&gt; for line in f:...     print(line, end=&apos;&apos;)...This is the first line of the file.Second line of the file  </code></pre><p>　　如果想要读取文件中所有的行，也可以使用list(f)或者f.readlines()。<br>　　f.write(string)将字符串写入文件，函数返回写入字符的个数。</p><pre><code>&gt;&gt;&gt; f.write(&apos;This is a test\n&apos;)15  </code></pre><p>　　其他格式的对象需要先经过转换－转换成字符串（文本模式）或者二进制对象（二进制模式）：　　</p><pre><code>&gt;&gt;&gt; value = (&apos;the answer&apos;, 42)&gt;&gt;&gt; s = str(value)  # convert the tuple to string&gt;&gt;&gt; f.write(s)18  </code></pre><p>　　f.tell()返回文件中当前操作的位置，这个位置用开始位置到当前位置字节数或字符数表示。<br>　　可以使用f.seek(offset，from_what)函数改变文件当前操作的位置，from_waht只能取0,1或者2，0表示离文件开头处offset的位置，1表示离当前位置offset的位置，2表示离文件结尾offset的位置。  </p><pre><code>&gt;&gt;&gt; f = open(&apos;workfile&apos;, &apos;rb+&apos;)&gt;&gt;&gt; f.write(b&apos;0123456789abcdef&apos;)16&gt;&gt;&gt; f.seek(5)      # Go to the 6th byte in the file5&gt;&gt;&gt; f.read(1)b&apos;5&apos;&gt;&gt;&gt; f.seek(-3, 2)  # Go to the 3rd byte before the end13&gt;&gt;&gt; f.read(1)b&apos;d&apos;</code></pre><p>　　在文本文件中（以文本模式打开的文件），只会相对文件起始位置进行查找（例外是可以使用seek(0,2)定位文件结尾处）并且offset只能是f.tell（）可返回的值，或者为0.其他任何offset值都会产生非定义的行为。  </p><h3 id="用json格式存储"><a href="#用json格式存储" class="headerlink" title="用json格式存储"></a>用json格式存储</h3><p>　　字符串可以很容易地被写入或从文件中读取。读取数字需要一点额外的工作才能完成，因为read()方法只能返回字符串。当希望保存像嵌套列表或字典这种复杂的类型时，手动解析和格式化会变得异常复杂。<br>　　与其频繁地写代码和改代码去保存复杂的数据格式，不如使用流行的数据格式json,Python允许json格式和其他格式之间的相互转换。标准的模块被称为json，模块可以提取Python数据层级，并将它们转化为字符串；这个过程称为序列化。在序列化和街序列化之间，表示对象的字符串可以被存储在一个文件或数据中，或通过网络连接发送到远程主机上。  </p><pre><code>&gt;&gt;&gt; import json&gt;&gt;&gt; json.dumps([1, &apos;simple&apos;, &apos;list&apos;])  #数据json化&apos;[1, &quot;simple&quot;, &quot;list&quot;]&apos;   </code></pre><p>   另一个函数dump()，只会岁文本文件进行序列化。因此如果f是一个将要被写入数据的文本文件对象，可以如下操作：  </p><pre><code>json.dump(x,f)  #x为json格式数据，将x写入文件对象。  </code></pre><p>　　<br>　解析对象，若f是一个已经打开的文本文件对象，可以使用load()函数：  </p><pre><code>x = json.load(f)  </code></pre><p>　　 这些简单的序列化技术可以解决列表和字典数据类型的序列化问题，但对于其他随意的类实体，序列化还需要另外的操作。json模块说明文档有相关说明。</p><h1 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h1><p> 　　有两种错误：语法错误和异常。　　</p><h2 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h2><p>　　语法错误，也即语句分析错误，可能是在Python学习过程中最常见的错误：  </p><pre><code>&gt;&gt;&gt; while True print(&apos;Hello world&apos;)  #缺少：File &quot;&lt;stdin&gt;&quot;, line 1while True print(&apos;Hello world&apos;)           ^SyntaxError: invalid syntax  </code></pre><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>　　即使是句法声明和表达在句法构成上是完全正确的，在语句执行时还是可能出现错误。在执行过程中检测到的错误称为异常，异常不是无条件的错误。大多数异常并不是通过程序去解决，相反，是在运行结果中展示错误消息：　　</p><pre><code>&gt;&gt;&gt; 10 * (1/0)Traceback (most recent call last):　File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ZeroDivisionError: division by zero&gt;&gt;&gt; 4 + spam*3Traceback (most recent call last):　File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &apos;spam&apos; is not defined&gt;&gt;&gt; &apos;2&apos; + 2Traceback (most recent call last):　File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: Can&apos;t convert &apos;int&apos; object to str implicitly   </code></pre><p>   错误提示最后一行说明了发生了什么异常。异常有不同的种类，上述例子中的异常分别是ZeroDivisionError、NameError和TypeError。作为异常类型打印出来的字符串是发生的内置异常的名称。这对于所有内置的异常都是适用的，但是对于用户定义的异常（尽管它经常是很有用的）并不适用。标准异常名称是内置标识符（不保留关键字）。<br>　　这一行的其余部分根据异常的类型和原因提供更详细的信息。<br>　　错误消息的前面部分以堆栈回溯的形式显示了异常发生的上下文。一般来说，它包括一个堆栈回溯列出的源代码行；但是，它不会显示标准输入读取的行。  </p><h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2><p>　　可以编写程序去处理特定的异常。请看下面的示例，它向用户询问输入，直到输入一个有效的整数，但允许用户中断程序(使用Control-C或任何操作系统支持的中断方式)；注意，用户生成的中断是通过KeyboardInterrupt异常来实现的。  </p><pre><code>&gt;&gt;&gt;while True:        try:            x=int(input(&quot;Please input an number:&quot;))              break        except ValueError:            print(&quot;Oops! That was no valid number.Try again...&quot;)  </code></pre><p>　　try声明的工作方式如下：  </p><p>　　1. 首先，在try关键字和except关键字try语句会被执行；<br>　　2. 如果没有发生异常，except语句会被跳过不执行而且try语句执行结束；<br>　　3. 如果try语句执行过程中出现异常，剩下的语句会被跳过执行。如果发生的异常与except关键字后的异常类型匹配，except语句会被执行，然后又回到try语句重新执行；<br>　　4.如果发生的异常与except语句中命名的异常不匹配，则将其传递到外部try语句;如果没有找到处理程序，它就是一个未处理的异常，语句执行停止，并像上面那样显示异常消息。<br>　　一个try声明可以有两个或更多except语句去处理不同的异常。一种情况下，最多只有一个异常处理语句被执行。处理程序只处理在相应的try子句中出现的异常，而不是在相同的try语句的其他处理程序中。一个except语句将多个异常用一个tuple类型进行命名，例如:  </p><pre><code>except (RuntimeError, TypeError, NameError):    pass  </code></pre><p>　　如果一个类是相同的类或一个基类(但不是另一种方式)，那么在except语句中的类是可以兼容的(但另一种方式——派生类与基类不兼容)。例如，以下代码将以该顺序打印B、C、D:  </p><pre><code>class B(Exception):    passclass C(B):    passclass D(C):    passfor cls in [B, C, D]:    try:        raise cls()    except D:        print(&quot;D&quot;)    except C:        print(&quot;C&quot;)    except B:        print(&quot;B&quot;)  </code></pre><p>　　<br>　　请注意，如果except语句顺序调转(将except B放在最前面)，它将会打印B、B、B。<br>　　最后一个except语句可以省略异常名称，作为其他所有异常处理的方法。使用这个要非常小心，因为这样很容易掩盖真正的编程错误。它还可以用于打印错误消息，然后重新引发异常(允许调用方处理异常):  </p><pre><code>import systry:    f = open(&apos;myfile.txt&apos;)    s = f.readline()    i = int(s.strip())except OSError as err:    print(&quot;OS error: {0}&quot;.format(err))except ValueError:    print(&quot;Could not convert data to an integer.&quot;)except:    print(&quot;Unexpected error:&quot;, sys.exc_info()[0])    raise   </code></pre><p>　　try…except语句之外可以有else语句，当它出现时，必须是跟在except语句之后。else语句对try子句未引发异常时而必须需要执行的代码非常有用。例如:  </p><pre><code>for arg in sys.argv[1:]:    try:            f = open(arg, &apos;r&apos;)    except OSError:         print(&apos;cannot open&apos;, arg)    else:         print(arg, &apos;has&apos;, len(f.readlines()), &apos;lines&apos;)         f.close()  </code></pre><p>　　使用else语句要比在try子句中添加额外的代码好，因为它避免了意外地捕获由try…except语句保护的代码所引发的异常。<br>　　当异常发生时，它可能具有相关的值，也称为异常的参数。参数的存在和类型取决于异常类型。<br>　　except语句可以在异常名之后指定一个变量。该变量被绑定到一个异常实例，其参数存储在instance.args中。为了方便起见，定义<strong>str</strong>(用来直接直接打印异常实例的参数，而不必引用.args。也可以先实例化一个异常，然后再抛出异常，并根据需要添加任何属性。  </p><pre><code>try:    raise Exception(&apos;spam&apos;, &apos;eggs&apos;)except Exception as inst:    print(type(inst))    # the exception instance    print(inst.args)     # arguments stored in .args    print(inst)          # __str__ allows args to be printed directly,                 # but may be overridden in exception subclasses    x, y = inst.args     # unpack args    print(&apos;x =&apos;, x)    print(&apos;y =&apos;, y)  </code></pre><p>　　如果异常有争议，则将其打印为提示消息的最后一部分(‘ detail ‘)作为未处理异常。<br>　　<br>异常处理程序不只是处理在try子句中出现的异常，也可以处理在try子句中被调用的函数(甚至是间接的)出现的异常。例如:　　</p><pre><code>def this_fails():    x = 1/0try:    this_fails()except ZeroDivisionError as err:    print(&apos;Handling run-time error:&apos;, err)  </code></pre><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>　　 raise声明允许程序强制发生特定异常。例如：  </p><pre><code>&gt;&gt;&gt;raise NameError(&apos;HiThere&apos;)   Traceback (most recent call last):     File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;   NameError: HiThere   </code></pre><p>　　 唯一的参数对抛出的异常进行解释说明。为了抛出异常，raise后面必须是一个异常实体或者异常类（Exception的派生类）。如果传递了异常类，则不使用实参调用它的构造函数来隐式实例化。  </p><pre><code>raise ValueError  # shorthand for &apos;raise ValueError()&apos;  </code></pre><p>　　如果需要决定异常是否被抛出而不打算处理异常，下面例子提供了一个重新抛出异常的方式：  </p><pre><code>&gt;&gt;&gt; try:...     raise NameError(&apos;HiThere&apos;)... except NameError:...     print(&apos;An exception flew by!&apos;)...     raise...An exception flew by!Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;NameError: HiThere  </code></pre><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常  　　"></a>自定义异常  　　</h2><p>　　程序可以通过穿件新的异常类来命名它们自己的异常。但这些异常必须直接或间接派生自Excepttion类。<br>　　任何其他类可以完成的工作，异常类也可以实现，但它们一般会被定义的很简单，一般只提供一些供处理程序解析错误信息的属性。当创建一个可以抛出几个不同错误的模块时，一般的做法是在模块中创建一个异常的基类，然后创建几个子类分别对应一个特定的异常抛出条件：  </p><pre><code>class Error(Exception):    &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;    passclass InputError(Error):    &quot;&quot;&quot;Exception raised for errors in the input.    Attributes:        expression -- input expression in which the error occurred           message -- explanation of the error    &quot;&quot;&quot;    def __init__(self, expression, message):        self.expression = expression        self.message = messageclass TransitionError(Error):    &quot;&quot;&quot;Raised when an operation attempts a state transition that&apos;s not allowed.    Attributes:        previous -- state at beginning of transition        next -- attempted new state        message -- explanation of why the specific transition is not allowed    &quot;&quot;&quot;    def __init__(self, previous, next, message):        self.previous = previous        self.next = next        self.message = message  </code></pre><p>　　大多数异常定义的名字会以“Error”结尾，这与标准异常的命名方式相似。<br>　　许多标准模块一般会定义自己异常去处理函数定义过程中可能发生的错误。  </p><h2 id="定义异常清理动作"><a href="#定义异常清理动作" class="headerlink" title="定义异常清理动作"></a>定义异常清理动作</h2><p>　　try声明有另一个可选的语句，这个语句被用来定义在任何条件都可以执行的清理动作。比如：  </p><pre><code>&gt;&gt;&gt; try:...     raise KeyboardInterrupt... finally:...     print(&apos;Goodbye, world!&apos;)...Goodbye, world!KeyboardInterruptTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;  </code></pre><p>　　finally语句总是在离开try声明之前被执行，无论异常是否发生。当在运行try语句时发生了异常而异常又没被except语句处理，那么异常将会在finally语句运行之后再次被抛出。finally语句在即使try语句被break，continue或return跳出时，还是会被执行。例子如下 ；  </p><pre><code>&gt;&gt;&gt; def divide(x, y):...     try:...         result = x / y...     except ZeroDivisionError:...         print(&quot;division by zero!&quot;)...     else:...         print(&quot;result is&quot;, result)...     finally:...         print(&quot;executing finally clause&quot;)...&gt;&gt;&gt; divide(2, 1)result is 2.0executing finally clause&gt;&gt;&gt; divide(2, 0)division by zero!executing finally clause&gt;&gt;&gt; divide(&quot;2&quot;, &quot;1&quot;)executing finally clauseTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;  File &quot;&lt;stdin&gt;&quot;, line 3, in divideTypeError: unsupported operand type(s) for /: &apos;str&apos; and &apos;str&apos;  </code></pre><p>　正如所见，finally语句在任何情况下都会被执行。TypeError因除数是两个字符串而被抛出，但异常未被except语句处理，因此在finally语句执行之后，异常被再次抛出。<br>　在实际的应用程序中，finally语句一般被用于释放内部资源（像文件、网络连接之类的），而无需关注这些资源是否被成功使用。  </p><h2 id="预定义清理动作"><a href="#预定义清理动作" class="headerlink" title="预定义清理动作"></a>预定义清理动作</h2><p>　　一些对象会定义一些标准的清理动作，当对象不再被需要，而不管这些对象是否被使用成功还是失败时，就会清理对象。请看下面的示例，它试图打开一个文件并将其内容打印到屏幕上。  </p><pre><code>for line in open(&quot;myfile.txt&quot;):    print(line, end=&quot;&quot;)  </code></pre><p>　　这个代码的问题在于，在代码的这一部分已经完成之后，它会让文件打开一段不确定的时间。在简单脚本中，这可能不是个问题，但对于更大的应用程序来说可能是个大问题。with语句允许像文件这样的对象以某种方式使用，以确保它们总是快速而正确地被清理。　　</p><pre><code>with open(&quot;myfile.txt&quot;) as f:    for line in f:        print(line, end=&quot;&quot;)　　</code></pre><p>　　在with语句运行完毕之后，即使在程序执行过程中遇到问题，f文件总是会被正确关闭。  </p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>　　 类将一系列数据和函数方法捆绑在一起。创建一个新的类也就是创建一种新的对象，它允许创建这种类型的实体。每个类实例都可以有保持其自身状态的附加属性。类实体也可以有改变自身状态的函数方法。<br>　　与其他编程语言相比，Python的类机制赋予类少量的新语法和句法。这种机制是C++和Modula-3语言中类的混合。Python中的类提供所有标准面向对象编程：类继承机制允许多个基类，派生类可以重载它的基类的任何函数，并且函数可以调用基类中相同名字的函数。类对象可以包含任意数目、任意种类的数据。与模块一样，类也包含Python的动态性质：它们是在运行时创建的，并且可以在创建后进一步修改。<br>　　在C++中，实现动态性，类成员一般是public类型，并且所有的成员函数是虚函数。像在Smalltalk语言中，类本身就是对象，这就提供了类导入和重命名的语义。不像C++语言和Modula-3语言，Python内置类型可以被用作其他用户扩充功能的基类。同样，像C++中一样，大多数内置的具有特殊语法的操作符（运算操作符，下标操作符等）可以在类实体中重新定义。   </p><h2 id="名称和对象"><a href="#名称和对象" class="headerlink" title="名称和对象"></a>名称和对象</h2><p>　　对象具有唯一性，而多个名称可以绑定到同一个对象。在其他语言中这被称为混叠。在Python中，这种做法并不推荐，并且当处理基本非变类型时，混叠会被安全地忽略掉。当然，混叠在像列表、字典这种可变类型编程时可能会有特殊的作用。因为混叠在某种程度上很像指针。比如，传递一个对象的花销很少因为执行时实际传递的只是一个指针；并且如果一个函数通过参数传递更改一个对象，调用将会不需要像Pascal语言中那样由两个不同参数传递的机制。  </p><h2 id="Python作用域和命名空间"><a href="#Python作用域和命名空间" class="headerlink" title="Python作用域和命名空间"></a>Python作用域和命名空间</h2><p>　　在介绍类之前，先说说一些关于Python作用域的规定。类的定义可以看做是使用命名空间玩出的一些巧妙的技巧，并且您需要知道范围和名称空间如何工作才能完全理解发生了什么。<br>　　命名空间是从名称到对象的映射。大多数名称空间目前都是作为Python字典实现的，但这一点一般不是很明显，而且这种实现方法在以后有可能会改变。命名空间的例子：内置名称的集合（包括像abs()的函数和内置异常名称）；模块中的全局名；以及函数调用中的本地名称。在某种意义上对象的属性集合也形成了一个命名空间。关于命名空间最重要的时在不同命名空间中的名称是绝对的无关联的；比如，用户可以在两个不同的模块定义一个都叫做maximize的函数，使用时通过添加模块名前缀就可以将两个函数区分。<br>　　对象的属性可能是只读或可写的。在下面的例子中，对象属性是可能被重新设置的。模块属性可重写：可以设置 modname.the_answer=42.可写属性也可以通过del语句进行删除。比如，del modname.the_answer将会从对象中移除the<em>answer属性。<br>　　命名空间会在不同时候被创造并拥有不同的生命周期。当Python解释器开始运行时包含内置名称的命名空间开始被创建，且不可删除。模块中的全局命名空间在模块的定义被读取时创建；一般情况下，模块的命名空间的生命周期会持续到解释器退出之时。 解释器的顶层调用所执行的语句，要么从脚本文件中读取，要么是交互式的，被认为是称为\</em>_main__的模块的一部分，因此它们有自己的全局名称空间。(内置的名字也存在一个模块中，这个模块被称为builtins)<br>　　函数的本地命名空间在函数被调用时创建，并且在函数返回或抛出一个围在函数内部处理的异常时被销毁。当然，递归调用的每次调用都有他们自己的本地命名空间。<br>　　Python的命名空间是一个可以直接进入的文本区域。所谓直接进入已实施命名空间可以通过无限制的引用去在命名空间中找到特定的名称。<br>　　尽管作用域是静态确定的，但它们是动态使用的。在执行的任何时期，在能直接进入的命名空间至少有三个嵌套作用域。<br>1.最内层的作用域，执行时会最先被检索，包含本地命名；<br>2.函数内部的作用域，不包含本地命名和全局命名；<br>3.次外层作用域包含当前模块的全局命名；<br>4.最外层作用域（最后被检索）是包含内置名称的命名空间。<br>　　如果一个名字被声明为全局，那么所有的引用和赋值都直接指向包含模块全局名称的中间范围。重新绑定最内层作用域外部的变量，nonlocal声明可能会被用到，如果不声明非本地性，那些变量将会为只读格式（任何试图去重写该参数的做法都将只是简单地在最内层作用域中重新创建一个新的本地变量，而在最内层作用外部的变量没有变化）。<br>　　一般地，本地作用域引用（文本）当前函数的本地名称。在函数外部，本地作用域引用相同的命名空间作为全局作用域：模块的命名空间。类定义在局部范围内放置另一个名称空间。<br>　　理解作用域的原文定义很重要：定义在模块中一个函数的全局作用域就是那个模块的命名空间，无论这个函数的在那或被什么换成其他别名。另一方面，名称的检索是动态处理的，在执行时-然而，语言的定义倾向于静态命名的方案，因此在编译时，不依赖动态命名的方案。（实际上，局部变量已经静态的定义了）<br>　　 Python一个特用的习惯是：如果没有全局声明，那么对名称的分配总是会进入到最内层的作用域。名称的分配不会拷贝数据-它们只是将名称绑定到对象。同样对于名称的销毁：del x的声明删除的是由局部作用域对x的绑定引用。事实上，所有引入新名称的操作都会用到局部作用域：特别地，import声明以及函数定义绑定模块或局部作用域中的函数名称。<br>　　全局声明用于说明特定在全局作用域中的变量并且只能被限制在全局作用域的变量；nonlocal声明说明局部作用域中的变量并且只能被限制在局部作用域中。</p><h3 id="作用域及命名空间实例"><a href="#作用域及命名空间实例" class="headerlink" title="作用域及命名空间实例"></a>作用域及命名空间实例</h3><p>　　下面的例子展示了如何引用不同的作用域和命名空间，以及 global和nonlocal声明如何影响变量的绑定： 　　</p><pre><code>def scope_test():    def do_local():        spam=&quot;local spam&quot;    def do_nonlocal():        nonlocal spam        spam=&quot;nonlocal spam&quot;    def do_global():        global spam        spam=&quot;global spam&quot;    spam=&quot;test spam&quot;    do_local()    print(&quot;After local assignment:&quot;,spam)    do_nonlocal()    print(&quot;After nonlocal assignment:&quot;,spam)    do_global()    print(&quot;After global assignment:&quot;,spam)scope_test()print(&quot;In global scope:&quot;,spam)　　</code></pre><p>  程序的输出如下：　　</p><pre><code>After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spamIn global scope: global spam　　</code></pre><p>  例子中说明local分配(默认为local)并未改变scope_test对spam的绑定。nonlocal声明改变了scope_test对spam的绑定，并且global声明从模块级改变了spam的绑定。  </p><h2 id="初探类"><a href="#初探类" class="headerlink" title="初探类"></a>初探类</h2><p>　　类引入了一些新的语法，三种新的对象类型，以及一些新的语义。  </p><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>　　类最简单的定义形式如下:  </p><pre><code>class ClassName:&lt;statement-1&gt;...&lt;statement-N&gt;  </code></pre><p>　　类定义，如函数定义（def语句）必须在它们有任何效果之前执行。（可能会将雷达额定义放在if条件语句中的一个分支内，或者在一个函数内部。）<br>　　实际上，在类内部的定义将一般是函数的定义，但是其他的声明也是允许的，并且有时候这些其他声明也是有很大用处的。类内部定义的函数一般有一个特别形式的参数列表，这由类方法的调用规则所限定。<br>　　当进入一个类的定义，一个新的命名空间就被创建了，并且被用于局部作用域——因此，所有的局域变量将会分配到这个心新的命名空间。特别地，函数定义在这绑定新的函数名。<br>　　当类定义执行完成，一个类对象被创建。这基本上是由类定义所创建的名称空间内容的包装;我们将在下一节中了解更多关于类对象的知识。原始的局部作用域（在类定义被输入之前生效的）被恢复，类对象被绑定到类定义头中给定的类名（例子中的ClassName）。  </p><h3 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python基础&quot;&gt;&lt;a href=&quot;#Python基础&quot; class=&quot;headerlink&quot; title=&quot;Python基础&quot;&gt;&lt;/a&gt;Python基础&lt;/h1&gt;&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;h3 id=&quot;整数、浮点数和复数&quot;&gt;&lt;a href=&quot;#整数、浮点数和复数&quot; class=&quot;headerlink&quot; title=&quot;整数、浮点数和复数&quot;&gt;&lt;/a&gt;整数、浮点数和复数&lt;/h3&gt;&lt;p&gt;　　Python可以处理任意大的整数和浮点数，整数为int类型，浮点数为float类型。整数和浮点数均能够通过＋、－、*、/进行加减乘除运算。
    
    </summary>
    
      <category term="翻译·Python" scheme="http://focusok.xyz/categories/%E7%BF%BB%E8%AF%91%C2%B7Python/"/>
    
    
  </entry>
  
  <entry>
    <title>撩起你的胃口</title>
    <link href="http://focusok.xyz/2017/03/18/%E6%92%A9%E8%B5%B7%E4%BD%A0%E7%9A%84%E8%83%83%E5%8F%A3/"/>
    <id>http://focusok.xyz/2017/03/18/撩起你的胃口/</id>
    <published>2017-03-18T12:39:35.000Z</published>
    <updated>2018-01-07T12:20:12.047Z</updated>
    
    <content type="html"><![CDATA[<p>　　如果你要在电脑上处理大量的工作，最终你发现有一些工作你想要电脑自动化处理。比如：你希望在一大堆文本中进行‘查找并替换’的操作，或者以一种复杂的方式去给大量的图片重命名和重排序。或者你想要写一个小的本地数据库，或一个特别的界面应用，或是简单的小程序。<a id="more"></a><br>　　如果你是一个专业的软件开发者，你可能不得不使用几个C/C++/JAVA语言的库但发现通常的编写、编译、测试、重编译的周期很慢。也许你正在为一个代码库写测试套件，但发现编写测试代码是个巨大的工程。或者你已经写好了一个程序并希望这个程序能够使用其他扩展性的语言，而你并不希望用新语言去重新去完成整个程序的设计。<br>　　在所有上述提到的情景下，Python语言都是你最好的选择。<br>　　你可以编写Unix shell脚本或者Windows批处理文件去处理上述的任务，但shell脚本比较适合处理文件移动和文本数据更改，并不适合界面应用和游戏。你可以写C/C++/Java程序，但即使是完成程序草稿，也将会花费你大量时间。Python简单易用，可以兼容Windows，Mac OS X,以及Unix操作系统，并将帮助你更快速的处理那些任务。<br>　　Python简单而又实用，但它是一门真正的语言。比起shell脚本和批处理文件，它提供更多的结构和对大型项目的支持。另一方面，Python比C语言提供更多的错误检查，并且，作为一种高级语言，它内置高级数据类型，比如复杂的矩阵和字典类型。因为Python语言更通用的数据类型，使它在解决很多问题上比Awk甚至Perl语言更适合，至少很多东西在Python中处理和在那些语言中一样简单。<br>　　Python允许你将代码封装成组件，这样就可在其他Python程序中复用这些组件。当然也有大量的标准组件，你可以用作构建你程序的基础或者作为学习Python编程的示例。这些组件能够提供像文件I/O、系统响应、网络协议甚至像Tk这样的图形界面工具。<br>　　Python是一种解释性语言，这将会在程序开发的过程中节省你大量的时间，因为Python程序不需要编译和连接。Python解释器能够交互式去编写代码而不需要过多考虑整个程序，或者在自下而上开发过程中去测试功能，这使得很容易使用它去验证Python语言的每一个特性。当然，它还是一个方便的桌面计算器。<br>　　Python使程序简洁易读。下面几个原因使得使用Python编写的程序比用C、C++或Java编写的程序短的多：<br>　　1. 高级数据类型使你能使用简单的描述处理复杂的操作<br>　　2. 声明代码组由缩进代替了开始和结束括号<br>　　3. 不需要特意声明变量和参数<br>　　Python是可扩展的：如果你知道用C语言编程，那向解释器添加新内置函数和新组件将会很简单，无论是你想要程序以最大的速度进行关键的操作，还是连接Python代码到程序库，但这些扩展可能只能以操作二进制格式的文件进行（比如特定于供应商的图形库）。如果你真的对此感兴趣，你可以把Python解释器连接到用C语言编写的程序中并把它作为这个程序的扩展或命令语言。<br>　　顺便一提，Python语言是根据BBC喜剧片“Monty Python’s Flying Circus”命名的，无关乎爬行动物Python（巨蟒）。Monty Python短剧的引用不仅是允许的，而且是被鼓励的。<br>　　现在你对Python已经感到激动了，并想更详细的去检测它。因为学习语言的最好方式是去使用它，此教程要求当你阅读的同时使用Python解释器去使用它。<br>　　在下一章，将会分析解释器的运用机制，这些分析虽然很枯燥常见，但对后面成功实践示例很重要。<br>　　教程其他部分会通过例子介绍大量Python语言系统的特性，开始介绍简单的表达式、声明和数据类型，然后介绍函数和模块，最后接触像异常和自定义类等先进的概念。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　如果你要在电脑上处理大量的工作，最终你发现有一些工作你想要电脑自动化处理。比如：你希望在一大堆文本中进行‘查找并替换’的操作，或者以一种复杂的方式去给大量的图片重命名和重排序。或者你想要写一个小的本地数据库，或一个特别的界面应用，或是简单的小程序。
    
    </summary>
    
      <category term="翻译·Python教程" scheme="http://focusok.xyz/categories/%E7%BF%BB%E8%AF%91%C2%B7Python%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Python教程</title>
    <link href="http://focusok.xyz/2017/03/16/python%E6%95%99%E7%A8%8B/"/>
    <id>http://focusok.xyz/2017/03/16/python教程/</id>
    <published>2017-03-16T15:30:19.000Z</published>
    <updated>2018-01-07T12:20:56.637Z</updated>
    
    <content type="html"><![CDATA[<p>　　本教程翻译自Python官网<a href="https://docs.python.org/3/" target="_blank" rel="external">python教程</a>。<br>　　Python是一种强大、易学的编程语言。它拥有高效的高级数据结构，能够使用简单但有效的方式进行面向对象编程的。Python优雅的语法、动态类型以及自然的语言解析，使它成为许多领域大多数平台脚本处理和快速开发应用的理想语言。 <a id="more"></a><br>　　在<a href="https://www.python.org/" target="_blank" rel="external">Python网站</a>上的Python解释器和标准的扩展库均是开源的，它们能够兼容所有主流系统平台，你可以自由获取它们的源代码或者二进制文件，并可以自由分发。网站还提供了很多免费的第三方Python组件、应用程序、工具和附加的文档说明。<br>　　Python解释器很容易扩展新功能，你能够扩展嵌入使用C或者C++（或其他从C语言发展而来的语言）执行的数据格式。Python也很适于作为本地应用的扩展语言。<br>　　此教程非正式地向读者介绍Python语言系统的基本思想和特性。在实际实践中结合使用Python解释器对Python的学习是很有帮助的，但所有的例子都是完整独立的，因此此教程也能够离线阅读。<br>　　标准组件和元件的说明参见<a href="http://docs.python.org/3/library/index.html#library-index" target="_blank" rel="external">Python标准库</a>。<a href="http://docs.python.org/3/reference/index.html#library-index" target="_blank" rel="external">Python语言参考</a>对Python语言中的定义有更正式的说明。想要在C或C++中扩展Python可以参考<a href="http://docs.python.org/3/extending/index.html#extending-index" target="_blank" rel="external">Python解释器的扩展和嵌入</a>和<a href="http://docs.python.org/3/c-api/index.html#c-api-index" target="_blank" rel="external">Python/C API参考手册</a>。当然还有其他深入介绍Python的书籍。<br>　　此教程不会尝试涵盖Python的所有特性，甚至不会完全涵盖说明所有的常用特性。相反，它会集中介绍Python中最引人注目的特性，并将带给你对语言风格的认识。经此教程，你将能够读写Python组件和应用程序，也为你以后阅读使用<a href="http://docs.python.org/3/library/index.html#library-index" target="_blank" rel="external">Python标准库</a>中更多丰富的Python标准库组件做好准备。<br>　　教程目录  </p><ol><li>Whetting Your Appetite  </li><li>Using the Python Interpreter<br>2.1  Invoking the Interpreter<br>  2.1.1  Argument Passing<br>   2.1.2  Interactive Mode<br>2.2. The Interpreter and Its Environment<br>   2.2.1 Source Code Encoding</li><li>An Informal Introduction to Python<br> 3.1. Using Python as a Calculator<br>   3.1.1. Numbers<br>   3.1.2. Strings<br>   3.1.3. Lists<br> 3.2. First Steps Towards Programming</li><li>More Control Flow Tools<br> 4.1. if Statements<br> 4.2. for Statements<br> 4.3. The range() Function<br> 4.4. break and continue Statements, and else Clauses on Loops<br> 4.5. pass Statements<br> 4.6. Defining Functions<br> 4.7. More on Defining Functions<br>   4.7.1. Default Argument Values<br>   4.7.2. Keyword Arguments<br>   4.7.3. Arbitrary Argument Lists<br>   4.7.4. Unpacking Argument Lists<br>   4.7.5. Lambda Expressions<br>   4.7.6. Documentation Strings<br>   4.7.7. Function Annotations<br> 4.8. Intermezzo: Coding Style</li><li>Data Structures<br>5.1. More on Lists<br>   5.1.1. Using Lists as Stacks<br>   5.1.2. Using Lists as Queues<br>   5.1.3. List Comprehensions<br>   5.1.4. Nested List Comprehensions<br>5.2. The del statement<br>5.3. Tuples and Sequences<br>5.4. Sets<br>5.5. Dictionaries<br>5.6. Looping Techniques<br>5.7. More on Conditions<br>5.8. Comparing Sequences and Other Types</li><li>Modules<br>6.1. More on Modules<br>   6.1.1. Executing modules as scripts<br>   6.1.2. The Module Search Path<br>   6.1.3. “Compiled” Python files<br>6.2. Standard Modules<br>6.3. The dir() Function<br>6.4. Packages<br>   6.4.1. Importing * From a Package<br>   6.4.2. Intra-package References<br>   6.4.3. Packages in Multiple Directories</li><li>Input and Output<br>7.1. Fancier Output Formatting<br>   7.1.1. Old string formatting<br>7.2. Reading and Writing Files<br>   7.2.1. Methods of File Objects<br>   7.2.2. Saving structured data with json</li><li>Errors and Exceptions<br>8.1. Syntax Errors<br>8.2. Exceptions<br>8.3. Handling Exceptions<br>8.4. Raising Exceptions<br>8.5. User-defined Exceptions<br>8.6. Defining Clean-up Actions<br>8.7. Predefined Clean-up Actions</li><li>Classes<br>9.1. A Word About Names and Objects<br>9.2. Python Scopes and Namespaces<br>   9.2.1. Scopes and Namespaces Example<br>9.3. A First Look at Classes<br>   9.3.1. Class Definition Syntax<br>   9.3.2. Class Objects<br>   9.3.3. Instance Objects<br>   9.3.4. Method Objects<br>   9.3.5. Class and Instance Variables<br>9.4. Random Remarks<br>9.5. Inheritance<br>9.5.1. Multiple Inheritance<br>9.6. Private Variables<br>9.7. Odds and Ends<br>9.8. Iterators<br>9.9. Generators<br>9.10. Generator Expressions</li><li>Brief Tour of the Standard Library<br>10.1. Operating System Interface<br>10.2. File Wildcards<br>10.3. Command Line Arguments<br>10.4. Error Output Redirection and Program Termination<br>10.5. String Pattern Matching<br>10.6. Mathematics<br>10.7. Internet Access<br>10.8. Dates and Times<br>10.9. Data Compression<br>10.10. Performance Measurement<br>10.11. Quality Control<br>10.12. Batteries Included</li><li>Brief Tour of the Standard Library — Part II<br>11.1. Output Formatting<br>11.2. Templating<br>11.3. Working with Binary Data Record Layouts<br>11.4. Multi-threading<br>11.5. Logging<br>11.6. Weak References<br>11.7. Tools for Working with Lists<br>11.8. Decimal Floating Point Arithmetic</li><li>Virtual Environments and Packages<br>12.1. Introduction<br>12.2. Creating Virtual Environments<br>12.3. Managing Packages with pip</li><li>What Now?</li><li>Interactive Input Editing and History Substitution<br>14.1. Tab Completion and History Editing<br>14.2. Alternatives to the Interactive Interpreter</li><li>Floating Point Arithmetic: Issues and Limitations<br>15.1. Representation Error</li><li>Appendix<br>16.1. Interactive Mode<br>  16.1.1. Error Handling<br>  16.1.2. Executable Python Scripts<br>  16.1.3. The Interactive Startup File<br>  16.1.4. The Customization Modules　　 　　 　　</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本教程翻译自Python官网&lt;a href=&quot;https://docs.python.org/3/&quot;&gt;python教程&lt;/a&gt;。&lt;br&gt;　　Python是一种强大、易学的编程语言。它拥有高效的高级数据结构，能够使用简单但有效的方式进行面向对象编程的。Python优雅的语法、动态类型以及自然的语言解析，使它成为许多领域大多数平台脚本处理和快速开发应用的理想语言。
    
    </summary>
    
      <category term="翻译" scheme="http://focusok.xyz/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="python" scheme="http://focusok.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+github建站配置</title>
    <link href="http://focusok.xyz/2017/02/26/myfirstblog/"/>
    <id>http://focusok.xyz/2017/02/26/myfirstblog/</id>
    <published>2017-02-26T10:30:19.000Z</published>
    <updated>2018-01-07T12:20:40.461Z</updated>
    
    <content type="html"><![CDATA[<p><center></center></p><h1 id="Hexo-Github建站"><a href="#Hexo-Github建站" class="headerlink" title="Hexo+Github建站"></a>Hexo+Github建站</h1><h3 id="使用hexo和Gitpage建站配置"><a href="#使用hexo和Gitpage建站配置" class="headerlink" title="使用hexo和Gitpage建站配置"></a>使用hexo和Gitpage建站配置</h3><p>　　第一次使用hexo和GitPage建立自己的个人博客。如何用hexogithub创建自己的个人博客，这个自不必多说，网上有很多教程，参照教程就可以很简单将网站搭建起来，当然在这推荐<a href="http://www.cnblogs.com/MuYunyun/p/5927491.html" target="_blank" rel="external">http://www.cnblogs.com/MuYunyun/p/5927491.html</a>,这个教程讲的不能再详细了。当然遇到hexo上的问题，可以参考<a href="https://hexo.io/docs/" target="_blank" rel="external">hexo官网文档</a>，讲的也简单易懂。<a id="more"></a></p><h3 id="添加多说评论插件"><a href="#添加多说评论插件" class="headerlink" title="添加多说评论插件"></a>添加多说评论插件</h3><p>　　Hexo默认评论插件是Disqus，但Disqus访问较慢，需要注册,比较麻烦，多说可以用微博、qq等登录，无需注册，操作起来很方便.添加多说的步骤可以参考这个教程<a href="http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9" target="_blank" rel="external">http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9</a>.里面要提的是duoshuo_shortname的设置就是第一次登录多说在多说中设置的二级域名除掉.duoshuo.com的部分，比如我当时设置的是<a href="http://focusok.duoshuo.com,那么duoshuo_shortname设置为focusok。" target="_blank" rel="external">http://focusok.duoshuo.com,那么duoshuo_shortname设置为focusok。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;h1 id=&quot;Hexo-Github建站&quot;&gt;&lt;a href=&quot;#Hexo-Github建站&quot; class=&quot;headerlink&quot; title=&quot;Hexo+Github建站&quot;&gt;&lt;/a&gt;Hexo+Github建站&lt;/center&gt;&lt;/h1&gt;&lt;h3 id=&quot;使用hexo和Gitpage建站配置&quot;&gt;&lt;a href=&quot;#使用hexo和Gitpage建站配置&quot; class=&quot;headerlink&quot; title=&quot;使用hexo和Gitpage建站配置&quot;&gt;&lt;/a&gt;使用hexo和Gitpage建站配置&lt;/h3&gt;&lt;p&gt;　　第一次使用hexo和GitPage建立自己的个人博客。如何用hexogithub创建自己的个人博客，这个自不必多说，网上有很多教程，参照教程就可以很简单将网站搭建起来，当然在这推荐&lt;a href=&quot;http://www.cnblogs.com/MuYunyun/p/5927491.html&quot;&gt;http://www.cnblogs.com/MuYunyun/p/5927491.html&lt;/a&gt;,这个教程讲的不能再详细了。当然遇到hexo上的问题，可以参考&lt;a href=&quot;https://hexo.io/docs/&quot;&gt;hexo官网文档&lt;/a&gt;，讲的也简单易懂。
    
    </summary>
    
      <category term="网站" scheme="http://focusok.xyz/categories/%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="配置" scheme="http://focusok.xyz/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
</feed>
