<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hurrican</title>
  <icon>https://www.gravatar.com/avatar/aa3c406e9be772646e8349e7f61092c9</icon>
  <subtitle>走自己的路，让别人去说</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://focusok.xyz/"/>
  <updated>2020-02-22T00:36:02.470Z</updated>
  <id>http://focusok.xyz/</id>
  
  <author>
    <name>hurricane</name>
    <email>hurricanhup@sina.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>项目管理</title>
    <link href="http://focusok.xyz/2020/02/19/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B/"/>
    <id>http://focusok.xyz/2020/02/19/项目管理流程/</id>
    <published>2020-02-19T11:17:40.000Z</published>
    <updated>2020-02-22T00:36:02.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理　　"></a><p align="left">项目管理</p>　　</h1><p>  　　一说到项目，我们都会想到像桥梁建设、摩天大楼建设等大工程，但实际在我们生活中有大大小小的很多项目，比如说房子装修、结婚等，甚至我们每个人的一生对自己来说都可以看做一个时间跨度很长的项目。项目作为一种一次性和独特性的社会活动而普遍存在于我们人类社会的各项活动之中，甚至可以说是人类现有的各种物质文化成果最初都是通过项目的方式实现的，因为现有各种运营所依靠的设施与条件最初都是靠项目活动建设或开发的。项目管理经过几十年的研究和发展，已经形成较为成熟的理论，具有标准化的流程。<a id="more"></a><br>　　项目的来源很多，可能是现实生产力提升的需要，也可能是为解决某个瓶颈问题而设立的，还有可能是老板的突发奇想。但项目启动前需要对项目进行评估，对项目的目标、必要性、方案的可行性进行评估。待项目真正确立后，才是项目的真正开始。　那项目如何开始，如何进行呢？下面就是标准化的流程。　</p><h2 id="1-项目启动"><a href="#1-项目启动" class="headerlink" title="1.     项目启动 "></a><p align="left">1.     项目启动 </p></h2><p>　　万事开头难，好的开头是成功的一半，在项目管理中项目启动是十分重要的。在项目启动前，项目申报书已经确立了项目的目标、主要里程碑、预算以及主要风险，以及项目成员。<br>　　确定一个合适的项目经理，一个合适的项目经理能够多快好省地完成项目。<br>  　　接下来，需要做的是，项目经理根据经验或项目要求识别项目干系人，分析干系人并制定管理策略。<br>  　　万事具备后，顺其自然,开一个启动大会将项目向各干系人进行宣告。　项目启动大会怎么开？可以参照如下流程：<br>  　　1.介绍会议议程　<br>　　2.领导讲话，阐述项目背景和战略<br>　　3.阐述项目目标，项目四要素范围（要干什么），时间（什么时候干），质量（标准），成本<br>　　4.介绍子模块计划（成员介绍）<br>　　5.沟通机制规定（介绍，周会、月会等）<br>　　6.领导确认和激励，向项目经理授权<br>　　7.下一步行动，责任人（项目经理介绍）<br>　　8.感谢大家（吃饭等）  　　  </p><h2 id="2-规划"><a href="#2-规划" class="headerlink" title="2.    规划"></a><p align="left">2.    规划</p></h2><p>　　根据成本、时间、质量的约束，对范围（要做什么）做加减法，确定范围后，对范围进行分解排序，规划时间，成本分解（CPI SPI）。</p><h2 id="3-执行"><a href="#3-执行" class="headerlink" title="3.    执行"></a><p align="left">3.    执行</p></h2><p>　　（1）人员管理（三种类型人员管理）  </p><p>   　　　　高瞻远瞩型（挑战惯性思维，不受群体约束，不善于真正完成工作，可能会让范围蔓延）<br>   　　　　按部就班型（着手准备开始做事、非常高效的个人贡献者、没有充分考虑好就采取行动，可能会造成返工）　　<br>   　　　　以终为始型（项目需要符合预算、将事情从后往前退，分清楚实现的阶段或步骤，开始的很慢，可能成为“分析瘫痪”者）<br>　　（2）四种涉及人员管理<br>　　　　　执行者：执行R<br>　　　　　负责人：负责（最终要）A<br>　　　　　知情者：告知 I<br>　　　　　咨询者：专家C<br>　　RAIC管理，A＞R＞C＞I，具体负责人应该负责与其他部门协调，确实有困难再找项目经理帮忙，责任主体还在A。<br> 　　(3) 沟通管理<br>  　　　原则：以身作则<br>　　　五大方面考虑：<br>　　　沟通视角、沟通姿态、沟通方式、沟通意识、沟通初衷<br>　　(4) 非职权影响力  </p><table><thead><tr><th style="text-align:center">维度</th><th style="text-align:center">说明</th><th style="text-align:center">提升方法  </th></tr></thead><tbody><tr><td style="text-align:center"> 信任（人）</td><td style="text-align:center">信表现</td><td style="text-align:center">承诺一致性  </td></tr><tr><td style="text-align:center"></td><td style="text-align:center">信任品</td><td style="text-align:center">牢记初心  </td></tr><tr><td style="text-align:center">专业（能）</td><td style="text-align:center">信权威</td><td style="text-align:center">打磨自己的权威，借力别人的权威  </td></tr><tr><td style="text-align:center"></td><td style="text-align:center">信逻辑</td><td style="text-align:center">理清逻辑  </td></tr><tr><td style="text-align:center">情绪（情）</td><td style="text-align:center">信情怀</td><td style="text-align:center">诉诸情怀  </td></tr><tr><td style="text-align:center"></td><td style="text-align:center">信情绪</td><td style="text-align:center">展露气魄  </td></tr><tr><td style="text-align:center">互惠（债）</td><td style="text-align:center">信双赢</td><td style="text-align:center">了解并寻求对方诉求的满足  </td></tr><tr><td style="text-align:center"></td><td style="text-align:center">信平衡</td><td style="text-align:center">提供支持和帮助，救急   </td></tr></tbody></table><h2 id="4-监控"><a href="#4-监控" class="headerlink" title="4.    监控"></a><p align="left">4.    监控</p></h2><p>（1）    查风险<br>　　a 墨菲定律：任何事都没有表面看起来那么简单，所有的事都会比你预期的时间长，会出错的事总会出错，如果你担心某种情况发生，那么它就更有可能发生。<br>　　b 项目过程充满风险<br>（2）    排列风险优先级　<br>  　　概率*影响=优先级<br>（3）    规划风险应对措施<br>　　　四类风险：<br>　　　影响高概率小：到时制定应急计划<br>　　　影响高概率高：立即修订原始计划<br>　　　影响小概率低：不修订，依原计划进行，监督即可<br>　　　影响小概率高：不修订原计划，稍做备案<br>（4）解决问题<br>　　　项目风险的定义：在什么期间，可能发生什么，因而都会对您关注……，产生……影响<br>　　　运用检查清单，识别项目风险。</p><h2 id="5-收尾"><a href="#5-收尾" class="headerlink" title="5. 收尾"></a><p align="left">5. 收尾</p></h2><p>（1）庆功<br>（2）奖金分配<br>（3）总结教训</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;项目管理&quot;&gt;&lt;a href=&quot;#项目管理&quot; class=&quot;headerlink&quot; title=&quot;项目管理　　&quot;&gt;&lt;/a&gt;&lt;p align=&quot;left&quot; &gt;项目管理&lt;/p&gt;　　&lt;/h1&gt;&lt;p&gt;  　　一说到项目，我们都会想到像桥梁建设、摩天大楼建设等大工程，但实际在我们生活中有大大小小的很多项目，比如说房子装修、结婚等，甚至我们每个人的一生对自己来说都可以看做一个时间跨度很长的项目。项目作为一种一次性和独特性的社会活动而普遍存在于我们人类社会的各项活动之中，甚至可以说是人类现有的各种物质文化成果最初都是通过项目的方式实现的，因为现有各种运营所依靠的设施与条件最初都是靠项目活动建设或开发的。项目管理经过几十年的研究和发展，已经形成较为成熟的理论，具有标准化的流程。
    
    </summary>
    
      <category term="项目管理" scheme="http://focusok.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="项目" scheme="http://focusok.xyz/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Python学习</title>
    <link href="http://focusok.xyz/2018/01/21/python%E5%AD%A6%E4%B9%A0/"/>
    <id>http://focusok.xyz/2018/01/21/python学习/</id>
    <published>2018-01-21T15:17:40.000Z</published>
    <updated>2018-09-02T14:52:12.096Z</updated>
    
    <content type="html"><![CDATA[<p>说明：该教程翻译自Python官网教程，该教程为python的语法基础，不包含Python流行库的介绍，需要查看英文原文，请点击<a href="https://docs.python.org/3/tutorial/index.html" target="_blank" rel="external">https://docs.python.org/3/tutorial/index.html</a><a id="more"></a> </p><h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数、浮点数和复数"><a href="#整数、浮点数和复数" class="headerlink" title="整数、浮点数和复数"></a>整数、浮点数和复数</h3><p>　　Python可以处理任意大的整数和浮点数，整数为int类型，浮点数为float类型。整数和浮点数均能够通过＋、－、*、/进行加减乘除运算。  </p><pre><code>&gt;&gt;&gt;2+2   4    &gt;&gt;&gt;&gt;5/2  2.5  &gt;&gt;&gt;5*1.8  9.0</code></pre><p>　　一般除法运算/得到的数据类型默认为浮点数类型，如果想得到商的整数部分，使用//,想得到余数使用%。  </p><pre><code>&gt;&gt;&gt;5//2  2  &gt;&gt;&gt;5%2  1</code></pre><p> 　　在Python中，**相当于幂运算。  </p><pre><code>&gt;&gt;&gt;3**3  27&gt;&gt;&gt;(-3)**29</code></pre><p>　　Python还内置了复数的定义和运算，’j’或J表示虚部，复数一般表示为a+bj。  </p><pre><code>&gt;&gt;&gt;(3+2j)/(1+5j)  (0.5-0.5j)&gt;&gt;&gt;(1+3j)*(2+2j)  (-4+8j)</code></pre><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>　　除了数字Python还能操作字符串。字符串可以使用单引号’…’或者双引号”…”的方式表示，若引号内有引号为字符串的内容，使用\排除歧义。  </p><pre><code>&gt;&gt;&gt;&apos;hello world&apos;  &apos;hello world&apos;&gt;&gt;&gt;&apos;Lilei\&apos;s hat&apos;&quot;Lilei&apos;s hat&quot;&gt;&gt;&gt;&apos;Lilei say:&quot;how are you？&quot;&apos;&apos;Lilei say:&quot;how are you？&quot;&apos;&gt;&gt;&gt;&quot;\&quot;yes,\&quot;he said&quot;&apos;&quot;yes,&quot;he said&apos;  &gt;&gt;&gt;&apos;&quot;yes,you are good,&quot;he said.&apos;&apos;&quot;yes,you are good,&quot;he said.&apos; #单引号中的双引号不产生歧义  &gt;&gt;&gt;&quot;isn&apos;t he?&quot;  &quot;isn&apos;t he?&quot;  #双引号中的单引号也不产生歧义  </code></pre><p>　　如果不想将\解释为转义字符，只需要在引用号前加r，表示原生（raw）保留。  </p><pre><code>&gt;&gt;&gt;print(&apos;C:\X\name&apos;)  #\n为换行字符C:\X  ame  &gt;&gt;&gt;print(r&apos;C:\X\name&apos;)  C:\X\name  </code></pre><p>　　字符串还可以使用+进行合并操作，使用*作为重复操作。（没有-和/的运算）  </p><pre><code>&gt;&gt;&gt;3*&apos;im&apos;&apos;imimim&apos;&gt;&gt;&gt;3*&apos;im&apos;+&apos;k&apos;  &apos;imimimk&apos;   </code></pre><p>　　<br>  　字符串可以根据下标读取内容，第一个字符下标为０.但下标所取超出实际下标范围将会报错。　　</p><pre><code>&gt;&gt;&gt;word=&apos;python&apos;  &gt;&gt;&gt;word[0]  &apos;p&apos;  &gt;&gt;&gt;word[5]&apos;n&apos;&gt;&gt;&gt;word[-1] #最后一个字符&apos;n&apos;&gt;&gt;&gt;word[-2] #倒数第二个字符&apos;o&apos;&gt;&gt;&gt;word[20]...IndexError:string index out of range</code></pre><p>　　    字符串还可以进行切片运算进行部分字符的选取。切片运算a[x:y:z],表示字符串a中从下标x开始步进为z取字符，取到下标为y截止所组成的字符串。但切片运算下标超出范围时，将不会报故障。  </p><pre><code>&gt;&gt;&gt;word=&apos;abcdefghijklmn&apos;&gt;&gt;&gt;word[1:4] #默认为word[1:4:1]&apos;bcd&apos;&gt;&gt;&gt;word[1:8:2]&apos;bdfh&apos;&gt;&gt;&gt;word[-8:8:2]&apos;fh&apos; &gt;&gt;&gt;word[18:20] &apos; &apos;           #返回空  </code></pre><p>　　字符串不允许使用下标对单个或部分字符直接赋值来改变字符串。  </p><pre><code>&gt;&gt;&gt;word[0]=&apos;k&apos;...TypeError: &apos;str&apos; object does not support item assignment&gt;&gt;&gt;word[1:]=&apos;bcdefghijklmn&apos;...TypeError: &apos;str&apos; object does not support item assignment  </code></pre><p>　   内置函数len()返回字符串的长度。  </p><pre><code>&gt;&gt;&gt;len(&apos;abcde&apos;)5 &gt;&gt;&gt;len(&apos;你好！&apos;)3  </code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>　　Python中内置很多聚合型数据类型将不同的值聚合在一起。其中最重要最常见的莫过于列表了。列表使用一对方括号将不同数据组合在一起，这些组合的数据可以是不同的数据格式。  </p><pre><code>&gt;&gt;&gt;s=[1,2,3]&gt;&gt;&gt;s[1,2,3]&gt;&gt;&gt;a=[1,&apos;b&apos;]&gt;&gt;&gt;a[1,&apos;b&apos;]</code></pre><p>　　和字符串一样（任何其他内置的序列类型数据），列表也可以进行切片操作。  </p><pre><code>&gt;&gt;&gt;s[1:-1][2]&gt;&gt;&gt;s[1:][2,3]  </code></pre><p>　　列表也可以使用“+”操作符，进行连接操作。</p><pre><code>&gt;&gt;&gt;s+[3,4,5,6,7][1,2,3,3,4,5,6,7]  </code></pre><p>　　但列表不同于字符串的是列表是可以更改的，列表可以直接通过下标进行赋值。</p><pre><code>&gt;&gt;&gt;cube=[1,8,27,67,125]&gt;&gt;&gt;cube[1,8,27,67,125]&gt;&gt;&gt;cube[3]=64&gt;&gt;&gt;cube[1,8,27,64,125]&gt;&gt;&gt;cube[0:3]=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]&gt;&gt;&gt;cube[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,64,125]  &gt;&gt;&gt;cube[0:3]=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]&gt;&gt;&gt;cube[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,64,125]  </code></pre><p>　　　可以使用append()函数在列表后面添加元素。</p><pre><code>&gt;&gt;&gt;cube.append(6**3)&gt;&gt;&gt;cube[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,64,125,216]  </code></pre><p>　　　同样len（）函数也可以返回列表的长度（元素个数）。</p><pre><code>&gt;&gt;&gt;len([1,2],3)  #列表的元素可以是列表2  </code></pre><h2 id="通往Python编程的第一步"><a href="#通往Python编程的第一步" class="headerlink" title="通往Python编程的第一步"></a>通往Python编程的第一步</h2><p>　　当然，使用Python可以完成比计算更复杂的任务。比如，可以使用Python写出Fibonacci数列：  </p><pre><code>&gt;&gt;&gt;#Fibonacci series:...a,b=0,1&gt;&gt;&gt;while b&lt;10:...     print(b)...     a,b=b,a+b...12358</code></pre><p>　　<br>　　上述代码中第一行以#开头为注释，无其他作用，仅是说明下面代码完成的功能是打印Fibonacci数列，第2行定义两变量并赋初值为0、1，接下来是一个While循环，在循环的条件b&lt;10的情况下进行打印b值和累加。不同于C或C++语言，整个代码结构层次不使用；和{}进行区别，而是使用缩进量，两行代码缩进相同，表示进行的操作在同一个层级。</p><h2 id="流控制语句"><a href="#流控制语句" class="headerlink" title="流控制语句"></a>流控制语句</h2><p>　　除了while循环语句，和其他语言一样，Python还有很多其他流控制语句。  </p><h3 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h3><p>　　最常用的语句莫过于if条件语句，如下例：  </p><pre><code>&gt;&gt;&gt;a=int(input(&quot;Please enter an integer:&quot;))Please enter an integer:25&gt;&gt;&gt;if x&lt;0:          x=0        print(&apos;Negative changed to 0&apos;)    elif x==0:        print(&apos;0&apos;)    elif x==1:        print(&apos;Single&apos;)    else:        print(&apos;More&apos;)  ...  More</code></pre><h3 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h3><p>　　for循环语句可能在Python中和C语言中稍微有点不一样。C语言中for循环语句一般给出循环的起始值、步进和结束值，Python中for语句按照特定的序列进行循环。例如：</p><pre><code>&gt;&gt;&gt;words=[&apos;cat&apos;,&apos;window&apos;,&apos;difference&apos;]&gt;&gt;&gt;for i in words:        print(i,len(i))...cat 3window 6difference 10</code></pre><p>　　如果需要根据循环的条件序列改变序列本身，最好先将序列的复制作为循环条件：</p><pre><code>&gt;&gt;&gt;for i in words[:]:  #该切片操作相当于words的复制，如果此处直接是 i in words，程序将会导致编译器死循环。        if len(i)&gt;6:            words.insert(0,i)...&gt;&gt;&gt;words[&apos;difference&apos;,&apos;cat&apos;,&apos;window&apos;,&apos;difference&apos;]</code></pre><h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h3><p>　　使用内置函数range()可以构建序列。</p><pre><code>&gt;&gt;&gt;for i in range(3):        print(i)...012&gt;&gt;&gt;list(range(5,10))[5,6,7,8,9]&gt;&gt;&gt;list(range(0,10,3))[0,3,6,9]</code></pre><p>　　　　结合range()和len()，可以产生C语言中for语句的效果。  </p><pre><code>&gt;&gt;&gt;a=[&apos;Peter&apos;,&apos;is&apos;,&apos;a&apos;,&apos;boy&apos;]&gt;&gt;&gt;for i in range(len(a)):        print(i,a[i])...0 Peter1 is 2 a  3 boy</code></pre><h3 id="break和continue以及循环中的else语句"><a href="#break和continue以及循环中的else语句" class="headerlink" title="break和continue以及循环中的else语句"></a>break和continue以及循环中的else语句</h3><p>　　同C语言中一样，break语句也是跳出最接近break一层的for或者while循环。<br>　　循环中也可以有else语句；当for循环终止或while循环判断条件为false时，跟在后面的else语句会运行一次，但如果有break语句提前终止循环，else语句将不会运行。  </p><pre><code>&gt;&gt;&gt;prime=[]&gt;&gt;&gt;for n in range(2,10):           for x in prime:            if n%x==0:            print(n,&apos;equals&apos;,x,&apos;*&apos;,n//x)            break            else:        #此处else语句不与if为一层，而是与for循环为一对            prime.append(n)            print(n,&apos;is a prime&apos;)    2 is a prime        #for x  in prime:循环运行终止，未遇到break跳出循环，else语句运行一次。    3 is a prime    4 equals 2 * 2      #break跳出循环，else语句未运行    5 is a prime    6 equals 2 * 3    7 is a prime    8 equals 2 * 4    9 equals 3 * 3</code></pre><p>　　continue语句也是从C语言中借鉴过来的，也是跳过当次循环中continue之后的操作。</p><pre><code>&gt;&gt;&gt;for num in range(2,5):        if num%2==0:            print(&quot;found an even number&quot;,num)            continue        print(&quot;Found a odd num&quot;,num)    found an even number 2    found an odd num 3    found an even number 4</code></pre><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>　　我们举一个打印任意范围内的Fibonacci数列的例子来说明如何定义函数：  </p><pre><code>&gt;&gt;&gt;def fib(n):          #函数实现打印n以内的Fibonacci数列        a,b=0,1        while a&lt;n:            print(a,end=&quot; &quot;)            a,b=b,a+b        print()&gt;&gt;&gt;fib(200)0 1 1 2 3 5 8 13 21 34 55 89 144   </code></pre><p>　　如上述例子，函数的定义以def作为关键字，后面紧跟着函数名称（例子中fib），括号内为函数参数列表，函数主体另起一行开始，且和关键字要有缩进。函数第一行一般会以#添加注释，以说明函数的功能或其他信息，添加注释是个很好的习惯，有很多工具可以根据这些注释自动生成说明文档，也使别人浏览代码时更简单易懂。<br>　　函数的执行会引进一个新的本地符号列表用以存储函数的局部变量。更确切的说，函数中所有变量的配置值存储在本地符号列表里；但是变量的引用会先在本地符号列表中查找，如果本地列表中没有，然后在封闭函数的本地变量列表中查找，接着是全局符号列表，最后还没找到，才会访问内置名称表中进行查找。因此全局变量不能在函数内部直接赋值（除非对变量进行了全局声明），虽然全局变量也可以被引用。<br>　　调用函数时，在函数的本地符号列表中引入函数调用的实际参数；因此，参数使用按特定值调用（这个特定值始终是调用对象的引用，而不是调用对象的值）。当一个函数调用另一个函数时，就会为该调用新建一个本地符号列表。<br>　　函数定义在当前符号表中引入函数名。函数名的值有一个被解释器作为用户定义函数识别的类型。该值可以分配给另一个名称，该名称也可以用作函数。这就是Python中重命名机制：  </p><pre><code>&gt;&gt;&gt;fib&lt;function fib at 0x0000000001D13E18&gt;&gt;&gt;&gt;f=fib&gt;&gt;&gt;f(20)0 1 1 2 3 5 8 13</code></pre><p>　　<br>　　上述函数并不返回值，也许你会因此而认为它不应该是一个函数而应该只是个执行过程。但实际上，及时函数没有return返回声明但还是会返回一个值；这个值被称为None（它是一个内置名）。如果None是函数唯一的返回值时，解释器一般会忽略这个返回值。如果想看到这个返回值，可以使用print():  </p><pre><code>&gt;&gt;&gt;fib(0)&gt;&gt;&gt;print(fib(0))None&gt;&gt;&gt;print(fib(20))0 1 1 2 3 5 8 13None</code></pre><p>　　要想返回Fibonacci序列很简单：</p><pre><code>&gt;&gt;&gt;def fib2(n):  #返回n以内的Fibonacci序列        result=[]        a,b=0,1        while a&lt;n:            result.append(a)   #在list最后插入a            a,b=b,a+b        return result&gt;&gt;&gt;s=fib2(20)&gt;&gt;&gt;s[0,1,1,2,3,5,8,13]</code></pre><h3 id="定义默认参数值"><a href="#定义默认参数值" class="headerlink" title="定义默认参数值"></a>定义默认参数值</h3><p>　　给函数定义默认的参数值能够使用函数时更灵活地调用参数。比如：</p><pre><code>def ask_ok(pro,retries=4,reminder=&apos;please try again!&apos;):    while True:        ok=input(pro)        if ok in (&apos;y&apos;,&apos;ye&apos;,&apos;yes&apos;):            return True        if ok in (&apos;n&apos;,&apos;no&apos;,&apos;nop&apos;,&apos;nope&apos;):            return False        retries=retries-1        if retries&lt;0:            raise ValueError(&apos;invalid user response&apos;)        print(reminder)</code></pre><p>　　<br>  上面的定义的ask_ok函数后两个参数给定了默认值，因此下面三种方法都可以调用此函数。  </p><pre><code>ask_ok(&apos;Do you want to quit?&apos;) ask_ok(&apos;Ok to overwrite the file?&apos;,2)　　ask_ok(&apos;Ok to overwrite the file?&apos;,2,&apos;Go ahead,only &quot;yes&quot; or &quot;no&quot;&apos;)  </code></pre><p>　　　但是给定默认的初值的参数一定要在未给定默认值参数之后，否则当调用参数缺省时，编译器将会报故。</p><pre><code>&gt;&gt;&gt;def ask_ok( retries=4, reminder=&apos;Please try again!&apos;,prompt):     while True:         ok = prompt           if ok in (&apos;y&apos;, &apos;ye&apos;, &apos;yes&apos;):                return True        if ok in (&apos;n&apos;, &apos;no&apos;, &apos;nop&apos;, &apos;nope&apos;):                return False        retries = retries - 1        if retries &lt; 0:             raise ValueError(&apos;invalid user response&apos;)        print(reminder)  &gt;&gt;&gt;ask_ok(&apos;y&apos;) ....SyntaxError: non-default argument follows default argument</code></pre><p>　　默认的参数值会在函数被定义的时刻就被赋值，因此：</p><pre><code>i=5def f(arg=i):    print(arg)i=6f()5           #函数在定义时，参数被赋值为5</code></pre><p>　　<br>　　默认的参数值只会被赋值一次。当默认参数值为像list、字典（dictionary）或大多数类实例的可变对象时。例如，下面的函数在后续调用中累积传递给它的参数：</p><pre><code>def f(a,L=[]):    L.append(a)    return Lprint(f(1))print(f(2))print(f(3))</code></pre><p>　　结果将会打印出  </p><pre><code>[1][1, 2][1, 2, 3]</code></pre><p>　　如果不想在以后的调用中共享默认值，你可以像这样编写函数：</p><pre><code>def f(a,L=None):    if L is None:        L=[]    L.append(a)    return L  </code></pre><h3 id="关键字参数调用"><a href="#关键字参数调用" class="headerlink" title="关键字参数调用"></a>关键字参数调用</h3><p>　　函数还可以使用kwarg=value形式的关键字进行参数调用。比如下面函数：　　</p><pre><code>def parrot(voltage, state=&apos;a stiff&apos;, action=&apos;voom&apos;, type=&apos;Norwegian Blue&apos;):    print(&quot;-- This parrot wouldn&apos;t&quot;, action, end=&apos; &apos;)    print(&quot;if you put&quot;, voltage, &quot;volts through it.&quot;)    print(&quot;-- Lovely plumage, the&quot;, type)    print(&quot;-- It&apos;s&quot;, state, &quot;!&quot;)　　</code></pre><p>　　函数接收一个必要参数和三个可选参数。参数的调用可以使用下面任意方式：</p><pre><code>parrot(1000)                                         parrot(voltage=1000)                                 parrot(voltage=1000000, action=&apos;VOOOOOM&apos;)            parrot(action=&apos;VOOOOOM&apos;, voltage=1000000)             parrot(&apos;a million&apos;, &apos;bereft of life&apos;, &apos;jump&apos;)        parrot(&apos;a thousand&apos;, state=&apos;pushing up the daisies&apos;)  </code></pre><p>　　但是像下面的调用方式，编译器将会报错：</p><pre><code>parrot()                     # 缺少不可缺省参数parrot(voltage=5.0, &apos;dead&apos;)  # 不允许非关键字参数在关键字参数之后 parrot(110, voltage=220)     # 给一个参数重复提供初值parrot(actor=&apos;John Cleese&apos;)  # 不可知的参数（未定义的参数）  </code></pre><p>　　当最后一个参数是以<em>*name的形式出现,表示函数接收一个字典类型（dict）参数（带有关键字的形参）。形参还可以</em>name的形式出现，表示函数接收一个元组（tuple）类型的参数。但如果函数参数列表中既要定义字典类型又有元组类型，字典类型一定要放在元组类型参数之后。比如下面例子：  </p><pre><code>def cheeseshop(kind,*arguments,**keywords):    print(&quot;--Do you have any &quot;,kind,&quot;?&quot;)    print(&quot;--I&apos;m sorry,We&apos;re all out off&quot;,kind)    for arg in arguments:        print(arg)    print(&quot;-&quot;*40)    for kw in keywords:        print(kw,&quot;:&quot;,keywords[kw])</code></pre><p>　　可以像下面调用函数：</p><pre><code>cheeseshop(&quot;Limburger&quot;,&quot;It&apos;s very runny,sir.&quot;,               &quot;It&apos;s really very runny ,sir.&quot;,             shopkeeper=&quot;Michael&quot;,client=&quot;John&quot;,            sketch=&quot;Cheese shop Sketch&quot;)  </code></pre><p>　　结果显示如下：　　</p><pre><code>--Do you have any  Limburger ?　　　　　　　＃　kind--I&apos;m sorry,We&apos;re all out off Limburger   ＃　kindIt&apos;s very runny,sir.                      ＃　argumentsIt&apos;s really very runny ,sir.              ＃　arguments----------------------------------------shopkeeper : Michael                     #keywordsclient : John                             #keywordssketch : Cheese shop Sketch               #keywords  </code></pre><p>　　</p><h3 id="任意参数列表"><a href="#任意参数列表" class="headerlink" title="任意参数列表"></a>任意参数列表</h3><p>　　最常见的做法是指定一个函数可以用任意数量的参数调用。这些参数将被封装在一个元组中（参见Tuples和序列）。在变量数目可变之前，可能出现零个或多个正常参数。  </p><pre><code>def  write_multiple_items(file,separator,*args)    file.write(separator.join(args))  </code></pre><p>　　一般情况下，可变参数放在形参列表的最后，因为它将会接收所有它之后传递过来的参数。任意在*args参数后定义赋值的参数只能是关键字参数，而不能是位置参数。</p><pre><code>def concat(*args,sep=&quot;/&quot;):    return sep.join(args)  print(concat(&quot;earth&quot;,&quot;Mars&quot;,&quot;venus&quot;))earth/Mars/venus  </code></pre><h3 id="Lambda函数（匿名函数）"><a href="#Lambda函数（匿名函数）" class="headerlink" title="Lambda函数（匿名函数）　　"></a>Lambda函数（匿名函数）　　</h3><p>　　小型匿名函数可以通过声明lambda关键字进行构建。像lambda a,b:a+b这个函数以a，b为参数，返回a,b的和。Lambda函数可以在任意需要定义函数的地方使用。但它们在语法上被限制为单句表达。像嵌套函数定义一样，lambda函数也可以引用其作用域内的变量：</p><pre><code>def make_incrementor(n):    return lambda x: x + nf = make_incrementor(42)f(1)43</code></pre><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><ol><li>使用4个空格进行代码层次区分，而不要使用TAB；</li><li>一行不要超过79个字符；</li><li>使用空白行将函数、类或在函数中的较大的代码块区分开；</li><li>尽可能将注释与需注释的代码放在同一行；</li><li>使用docstrings对代码进行说明；</li><li>在操作符和逗号前后尽量空一格；</li><li>定义类和函数名时风格尽量保持一致；通常做法是定义类使用骆驼拼写风格（SampleCase），定义函数和方法时使用lower_case_with_underscores的拼写风格。类的第一个方法使用self作为参数；</li><li>不要使用奇怪的编码方式去写代码；在任何情况下，Python默认的UTF-8，或者纯ASCII都是最好的编码方式；</li><li>同样地，如果使用不同语言的人阅读或维护代码的机会很小，请不要在标识符中使用非ASCII字符。</li></ol><p>#数据结构  </p><h3 id="list用作堆栈"><a href="#list用作堆栈" class="headerlink" title="list用作堆栈"></a>list用作堆栈</h3><p>　　列表方法使得使用列表作为堆栈（先进后出）非常容易。在堆栈顶部添加一个元素，可以使用append()。使用不带参数的pop()函数在堆栈顶部取出一个元素。比如：  </p><pre><code>&gt;&gt;&gt;stack=[3,4,5]&gt;&gt;&gt;stack.append(6)&gt;&gt;&gt;stack[3,4,5,6]&gt;&gt;&gt;stack.pop()6  </code></pre><h3 id="list用作队列"><a href="#list用作队列" class="headerlink" title="list用作队列"></a>list用作队列</h3><p>　　列表也可以被用作队列（先入先出），但列表用作队列并不方便。因为从队列底部插入和取出元素都很快，从队列头部很慢。<br>　　为实现一个队列，使用collections.deque,collections.deque能够实现列表两端的插入元素和取出元素。比如：  </p><pre><code>&gt;&gt;&gt;from collections import deque&gt;&gt;&gt;queue=deque([1,2,2,3,4])&gt;&gt;&gt;queue.append(&quot;mark&quot;)&gt;&gt;&gt;queue.popleft()1&gt;&gt;&gt;queue.popleft()2&gt;&gt;&gt;queuedeque([2,3,4,‘mark’])</code></pre><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>　　列表推导式提供了一个简洁的创建列表的方式。通常构建新列表元素的方法使根据一个序列或迭代器经过一些操作形成另一对应的结果，或满足特定条件下筛选出的子序列。比如：  </p><pre><code>&gt;&gt;&gt;s=[]&gt;&gt;&gt;for x in range(10):        s.append(x**3)&gt;&gt;&gt;s[0,1,8,27,64,125,216,343,512,729]</code></pre><p>　　也可以使用匿名函数形成列表：</p><pre><code>&gt;&gt;&gt;s=list(map(lambda x:x**2,range(5)))&gt;&gt;&gt;s[0,1,4,9,16]  </code></pre><p>　　也可以使用等式：  </p><pre><code>s=[x**2 for x in range(10)]&gt;&gt;&gt;[(x,y) for x in [1,2,3] for y in [3,1,4] if x!=y][(1,3),(1,4),(2,3),(2,1),(2,4),(3,1),(3,4)]  </code></pre><p>###嵌套列表推导式　　<br>　　　列表推导式的初始表达可以是任意的表达式，包括另一个列表推导式。例如下面的一个3*4的矩阵，它由一个内嵌3个长度为4的列表的列表形成：  </p><pre><code>&gt;&gt;&gt;matrix=[[1, 2, 3, 4],          [5, 6, 7, 8],          [9, 10, 11, 12]]  </code></pre><p>　　下面是转置该矩阵的列表推导式：</p><pre><code>&gt;&gt;&gt;[[row[i] for row in matrix] for i in range(4)][[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]  </code></pre><p>　　内嵌的列表推导式根据后面的for语句表达的顺序进行求值，因此上述推导式等价于：  </p><pre><code>&gt;&gt;&gt; transposed = []&gt;&gt;&gt; for i in range(4):  ...     transposed.append([row[i] for row in matrix])  ...&gt;&gt;&gt; transposed    [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]    </code></pre><p>　　进一步解析，等价于：</p><pre><code>&gt;&gt;&gt; transposed = []&gt;&gt;&gt; for i in range(4):...     transposed_row = []...     for row in matrix:...         transposed_row.append(row[i])...     transposed.append(transposed_row)...&gt;&gt;&gt; transposed[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]  </code></pre><p>　　也许在实际应用中，我们更喜欢用内置函数来实现复杂的表达式。zip（）函数可以很好的完成上述矩阵的转置：  </p><pre><code>&gt;&gt;&gt;list(zip(*matrix))[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]  </code></pre><h2 id="del表达式"><a href="#del表达式" class="headerlink" title="del表达式"></a>del表达式</h2><p>　　　del表达式可以根据列表的下标删除列表中的元素。这不同于pop()函数，pop()函数会返回元素的值，del不会。del表达式也可以使用切片删除列表中的多个元素，甚至删除整个列表。比如：</p><pre><code>&gt;&gt;&gt;a=[1,2,3,4,5,6]&gt;&gt;&gt;del a[0]&gt;&gt;&gt;a[2,3,4,5,6]&gt;&gt;&gt;del a[2:4]&gt;&gt;&gt;a[2,5,6]&gt;&gt;&gt;del a&gt;&gt;&gt;a........NameError: name &apos;a&apos; is not defined  </code></pre><h2 id="Tuples和序列"><a href="#Tuples和序列" class="headerlink" title="Tuples和序列"></a>Tuples和序列</h2><p>　　像list和string都是序列数据类型，它们有很多共同的特点，比如可以有下标，可以进行切片操作。Python语言中还存在另一种标准的序列数据类型：tuple。<br>　　定义tuple，tuple各元素之间用逗号隔开，比如：</p><pre><code>&gt;&gt;&gt;t=123,456,&apos;hi&apos;&gt;&gt;&gt;t(123,456,&apos;hi&apos;)&gt;&gt;&gt;t=(123,456,&apos;hi&apos;)  #定义tuple更标准的形式 &gt;&gt;&gt;t=tuple((123,456,&apos;hi&apos;)) #函数形式定义 &gt;&gt;&gt;u=t,(1,2,3,4)     #tuple还可以嵌套&gt;&gt;&gt;u((123,456,&apos;hi&apos;),(1,2,3,4))&gt;&gt;&gt;t[0]=0            #tuple是不可变序列Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;tuple&apos; object does not support item assignment&gt;&gt;&gt;v=([1,2,3],[3,2,1])   #tuple的元素可以是可变序列list&gt;&gt;&gt;v([1,2,3],[3,2,1])</code></pre><p>　　定义一些特殊的tuple类型对象，需要注意一些问题：</p><pre><code>&gt;&gt;&gt;empty=() #0个元素的tuple类型，一定要用括号&gt;&gt;&gt;m=&apos;hello&apos;, #定义一个元素的tuple类型，后面一定要加逗号 &gt;&gt;&gt;x,y,z=t&gt;&gt;&gt;x123&gt;&gt;&gt;y456&gt;&gt;&gt;z&apos;hi&apos;&gt;&gt;&gt;a,b=t......ValueError:not enough values to unpack(expected 2,got 1)  </code></pre><h2 id="集合（sets）"><a href="#集合（sets）" class="headerlink" title="集合（sets）"></a>集合（sets）</h2><p>　　set是一个无重复元素的无序合集。和数学中的概念一样，set也有并集、合集、差集等运算。</p><pre><code>&gt;&gt;&gt;basket={&apos;apple&apos;,&quot;orange&quot;,&apos;apple&apos;,&apos;pear&apos;,&apos;orange&apos;,&apos;banana&apos;}&gt;&gt;&gt;basket{&apos;orange&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;apple&apos;}  #自动删除重复元素&gt;&gt;&gt;basket=set((&apos;apple&apos;,&quot;orange&quot;,&apos;apple&apos;,&apos;pear&apos;,&apos;orange&apos;,&apos;banana&apos;))  #函数形式创建set&gt;&gt;&gt;&apos;orange&apos; in basket    True....&gt;&gt;&gt;a={&apos;qw&apos;,&apos;r&apos;}&gt;&gt;&gt;b={&apos;qw&apos;,&apos;m&apos;}&gt;&gt;&gt;a-b        #a,b的差集，只在a中元素的集合{&apos;r&apos;}&gt;&gt;&gt;a|b        #a,b的合集，在a或者在b中的元素的集合{&apos;m&apos;,&apos;qw&apos;,&apos;r&apos;}&gt;&gt;&gt;a&amp;b        #a,b的并集，同时在a,b中元素的集合{&apos;qw&apos;}&gt;&gt;&gt;a^b        #a，b集合的异或，在a或者b中，但不在a,b的并集中元素的集合{&apos;m&apos;,&apos;r&apos;}  </code></pre><p>　　同样，像list推导式，set推导式也是被支持的：</p><pre><code>&gt;&gt;&gt;a={x for x in &quot;abracadabra&quot; if x not in &apos;abc&apos;}&gt;&gt;&gt;a{&apos;r&apos;,&apos;a&apos;}  </code></pre><h2 id="字典（dict）"><a href="#字典（dict）" class="headerlink" title="字典（dict）"></a>字典（dict）</h2><p>　　dict（字典）是Python语言中一种很有用的数据类型。在其他语言中dict被称为关联内存或关联数组。不同于序列由一列数字索引，字典由关键字索引，关键字可以是任意的非变类型；所有字符串和数字都可以作为字典的关键字。tuple类型只有当其元素不含可变类型数据时可以作为关键字。list类型不能被用作字典的关键字。<br>　　理解字典类型，最好将它看成一个无序的key:value组的集合，在一个字典里，每个关键字是唯一的。一对花括号创建一个空的字典：{}。每个key:value对之间用逗号隔开。  </p><pre><code>&gt;&gt;&gt;tel={&apos;jack&apos;: 4098, &apos;sape&apos;: 4139,&apos;jack&apos;:3022}&gt;&gt;&gt;tel{&apos;jack&apos;:3022,&apos;sape&apos;: 4139}      #重复的关键字会保留最后一组key:value对，其他自动删除。&gt;&gt;&gt;tel[&apos;lili&apos;]=4423              #增加字典元素&gt;&gt;&gt;tel{&apos;jack&apos;:3022,&apos;sape&apos;: 4139,&apos;lili&apos;:4423}&gt;&gt;&gt;del tel[&apos;sape&apos;]&gt;&gt;&gt;tel{&apos;jack&apos;:3022,&apos;lili&apos;:4423}&gt;&gt;&gt;list(tel.keys())[&apos;jack&apos;,&apos;lili&apos;]&gt;&gt;&gt;sorted(tel.keys())[&apos;jack&apos;,&apos;lili&apos;]&gt;&gt;&gt;sorted(tel.values())[3022,4423]&gt;&gt;&gt;&apos;jack&apos; in telTrue</code></pre><p>　　dict()直接根据key-value序列创建字典：  </p><pre><code>&gt;&gt;&gt; dict([(&apos;sape&apos;, 4139), (&apos;guido&apos;, 4127), (&apos;jack&apos;, 4098)]){&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127}  </code></pre><p>　　字典推导式可以根据任意的关键字和值创建字典：  </p><pre><code>&gt;&gt;&gt;{x:x**2 for x in(1,2,3)}{1:1,2:4,3:9}  </code></pre><p>　　当关键字只为字符串，可以简化字典类型的创建：  </p><pre><code>&gt;&gt;&gt;dict(sape=4139, guido=4127, jack=4098){&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127}</code></pre><h2 id="循环技巧"><a href="#循环技巧" class="headerlink" title="循环技巧"></a>循环技巧</h2><p>　　当遍历字典时，关键字和相关的值可以通过items()方法同时提取。</p><pre><code>&gt;&gt;&gt; knights = {&apos;gallahad&apos;: &apos;the pure&apos;, &apos;robin&apos;: &apos;the brave&apos;}&gt;&gt;&gt; for k, v in knights.items():...     print(k, v)...gallahad the purerobin the brave  </code></pre><p>　　当遍历一个序列时，元素的位置和值可以通过enumerate()函数同时获取。  </p><pre><code>&gt;&gt;&gt; for i, v in enumerate([&apos;tic&apos;, &apos;tac&apos;, &apos;toe&apos;]):...     print(i, v)...0 tic1 tac2 toe  </code></pre><p>　　同时遍历两个序列，可以使用zip()函数：                 </p><pre><code>&gt;&gt;&gt; questions = [&apos;name&apos;, &apos;quest&apos;, &apos;favorite color&apos;]&gt;&gt;&gt; answers = [&apos;lancelot&apos;, &apos;the holy grail&apos;, &apos;blue&apos;]&gt;&gt;&gt; for q, a in zip(questions, answers):...     print(&apos;What is your {0}?  It is {1}.&apos;.format(q, a))...What is your name?  It is lancelot.What is your quest?  It is the holy grail.What is your favorite color?  It is blue.  </code></pre><p>　　反序遍历序列，调用reversed()函数，排序使用sorted()函数：</p><pre><code>&gt;&gt;&gt; for i in reversed(range(1, 10, 2)):   #resversed()返回的是一个迭代器类，而不是反序后的序列。...     print(i)...97531  </code></pre><p>　　有时候想在遍历序列的时候改变它，简单而又安全的方法是将新建一个序列。</p><pre><code>&gt;&gt;&gt; import math&gt;&gt;&gt; raw_data = [56.2, float(&apos;NaN&apos;), 51.7, 55.3, 52.5, float(&apos;NaN&apos;), 47.8]&gt;&gt;&gt; filtered_data = []&gt;&gt;&gt; for value in raw_data:...     if not math.isnan(value):...         filtered_data.append(value)...&gt;&gt;&gt; filtered_data[56.2, 51.7, 55.3, 52.5, 47.8]  </code></pre><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>　　如果退出了Python解释器并再次进入它，那之前的定义（函数或变量）都会丢失。因此，如果想编写更长的程序，最好使用一个文件编辑器去编写输入文件，使用解释器去运行这个文件，而不是直接在解释器中直接输入运行。这也就是所谓的编写脚本。当程序很长时，为了更易于维护，可能需要把它分成几个文件。当在多个程序中用到一个共同的函数时，你肯定也不希望在每个程序中重复地把这个函数再编写一遍。<br>　　为了满足上述情况，Python的方法是将定义放入文件并在脚本中或解释器的交互实例中使用它们。这些文件被称为模块；模块中的定义可以被其他模块或主模块（在顶层或计算器模式下执行的脚本中可以访问变量的集合）导入。<br>　　模块是一个包含Python定义和语句的文件。文件名就是模块名带.py后缀。在模块内部，模块的名字可以由全局变量<strong>name</strong>访问。用文本编辑器编写下列内容，并把文件命名为fibo.py保存在解释器运行目录下:</p><pre><code># Fibonacci numbers moduledef fib(n):    # write Fibonacci series up to n    a, b = 0, 1    while b &lt; n:        print(b, end=&apos; &apos;)        a, b = b, a+b    print()def fib2(n):   # return Fibonacci series up to n    result = []    a, b = 0, 1    while b &lt; n:        result.append(b)        a, b = b, a+b    return result    </code></pre><p>　　在解释器中输入导入该模块的命令：  </p><pre><code>&gt;&gt;&gt; import fibo</code></pre><p>　　此时的符号列表中没有fibo模块中定义的函数名；只用fibo在那。可以通过模块名进入模块中的函数：  </p><pre><code>&gt;&gt;&gt; fibo.fib(1000)1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987&gt;&gt;&gt; fibo.fib2(100)[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]&gt;&gt;&gt; fibo.__name__&apos;fibo&apos;</code></pre><h2 id="模块深入"><a href="#模块深入" class="headerlink" title="模块深入"></a>模块深入</h2><p>　　一个模块内可以包含任意像函数声明的可执行语句。    这些可执行声明只有在第一次遇到一个import声明时被执行。（或者当文件被当做一个脚本时，也可以直接执行）<br>　　每一个模块会有它各自的符号列表，这个符号列表会被作为模块中所有函数的全局符号类表。因此，因此，模块的作者可以在模块中使用全局变量，而不必担心与用户的全局变量发生意外冲突。另一方面，如果你知道你正在干什么，你可以直接以函数相同的符号（modname.item的形式）来触及模块的全局变量。<br>　　模块可以引用其他模块。一般会把模块所有的引用在模块开头就用import语句进行声明，但这并不是必须的。引用过的模块名也会被引入到模块的全局符号列表。　　<br>　　有很多直接引用模块的import声明形式。比如：</p><pre><code>&gt;&gt;&gt; from fibo import fib, fib2&gt;&gt;&gt; fib(500)1 1 2 3 5 8 13 21 34 55 89 144 233 377</code></pre><p>　　<br>　　但例子中的引入方式并没有将模块名（fibo）引入到本地符号列表中，也就是说上面例子中，fibo是没有被定义的。可以直接引用模块中所有的定义。</p><pre><code>&gt;&gt;&gt; from fibo import *&gt;&gt;&gt; fib(500)1 1 2 3 5 8 13 21 34 55 89 144 233 377    </code></pre><p>　　其他引用模块的形式：　　</p><pre><code>&gt;&gt;&gt; import fibo as fib&gt;&gt;&gt; fib.fib(500)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377　  </code></pre><h3 id="把模块当做脚本执行"><a href="#把模块当做脚本执行" class="headerlink" title="把模块当做脚本执行"></a>把模块当做脚本执行</h3><p>　　当用下面的语句运行Python模块时：  </p><pre><code>python fibo.py &lt;arguments&gt;  </code></pre><p>模块将会被执行，就像你把<strong>name</strong>设置为“<strong>main</strong>”时引用这个模块一样。  </p><pre><code>if __name__ == &quot;__main__&quot;:     import sys     fib(int(sys.argv[1]))  </code></pre><p>　　<br>如果你不加入上述代码，模块将不会像脚本一样运行，因为代码的解析只有当遇到“main”文件时才会被执行。  </p><h3 id="模块的查找路径"><a href="#模块的查找路径" class="headerlink" title="模块的查找路径"></a>模块的查找路径</h3><p>　　当一个名为spam的模块被导入时，解释器首先会查找内置模块中的spam。如果没有找到，那它就会根据所给的sys.path路径查找spam.py文件。sys.path可以是下面的路径形式：</p><p>　　　　</p><ol><li>包含所引入脚本的文件夹（若当下解析器的运行文件夹正式引用模块的所在文件夹，文件路径可以不必特殊说明）  　　　</li><li>　PYTHONPATH(一串和shell中PATH变量语法相同的文件名)  　</li><li>安装默认的依赖文件路径  </li></ol><p>　　当初始化之后，Python程序可以更改sys.path。因为包含脚本文件夹初始化sys.path的优先级是最高的，因此当引用的模块在包含的脚本文件夹中，同时有个相同名字的模块在标准模块库中时，解析器导入的时文件夹中的模块。  </p><h3 id="“编译”Python文件"><a href="#“编译”Python文件" class="headerlink" title="“编译”Python文件"></a>“编译”Python文件</h3><p>　　为了加速加载模块，Python将会把每个模块编译的版本缓存在__pycache__文件下module.version.pyc文件里，这个文件也就是该版本下的Python对编译文件进行编码的地方；它一般会包含Python的版本号。比如，在CPython3.3发布版中编译spam.py的文件将会被缓存为__pycache__/spam.cpython-33.pyc。这种命名的转换允许各种版本Python编译的模块共存。<br>　　Python会检查源代码的修改日期与编译后的版本，以查看是否过期，是否需要重新编译。这完全是一个自动进行的过程。并且，编译过的模块是不依赖于平台的，因此同样的库可以在不同架构的系统中共享。<br>　　Python会在两种情况下检查缓存。首先，它总是重新编译，并且不存储直接从命令行加载的模块的结果。其次，如果没有源模块，它将不会检查缓存。为了支持非源代码（仅编译的）的分发，编译后的模块必须位于源目录中，并且不能有一个源模块。  </p><p>TIPS:  </p><ol><li>可以用Python命令中加入-O或-OO去减小编译模块的大小。-O转换会删除源码中的断言语句，-OO转换会删除源码中的断言语句和__doc__字符串。  </li><li>当程序运行.pyc文件并不会比.py文件速度快。而是加载.pyc文件比.py文件快。  </li><li>compileall模块可以为一个文件夹下的所有模块穿件一个.pyc文件。  </li></ol><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>　　Python自带了一个标准模块的库。有些模块被内置到解释器里，这些模块提供对不属于语言核心部分的操作的访问，但它们是内置的，这对于无论是为了提高效率，还是提供对操作系统原语（如系统调用）的访问都是必需的。这些模块的集合也是有配置要求的，它也依赖于底层平台。比如，winreg模块只能用于Windows系统。一个值得注意的特殊模块是sys模块，它被内置在任意平台的Python解释器中。变量sys.path决定了解释器查找模块的路径。它默认由系统环境中PYTHONPATH变量初始化，或者在PYTHONPATH未被设置的情况下由一个默认的内置值初始化。可以使用标准列表操作更改它：</p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(&apos;/ufs/guido/lib/python&apos;)  </code></pre><h2 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a>dir()函数</h2><p>　　内置函数dir()被用于模块定义的名字，它返回一系列字符串。  </p><pre><code>&gt;&gt;&gt;import fibo,sys    &gt;&gt;&gt;dir(fibo)      [&apos;__builtins__&apos;,&apos;__cached__&apos;,&apos;__doc__&apos;,&apos;__file__&apos;,&apos;__l    oader__&apos;,&apos;__name__&apos;,&apos;__package__&apos;,&apos;__spec__&apos;,&apos;fib&apos;,&apos;fib2&apos;]&gt;&gt;&gt;import fibo,sys</code></pre><p>　　如果不带参数，dir()返回当前所定义的名字：  </p><pre><code>&gt;&gt;&gt;a=[1,2,3]&gt;&gt;&gt;import fibo&gt;&gt;&gt;fib=fibo.fib&gt;&gt;&gt;dir() [&apos;__annotations__&apos;,&apos;__builtins__&apos;,&apos;__doc__&apos;,&apos;__l    oader__&apos;,&apos;__name__&apos;,&apos;__package__&apos;,&apos;__spec__&apos;,&apos;a&apos;,&apos;fib&apos;,&apos;fibo&apos;]    </code></pre><p>　　dir()返回所有形式的命名：变量，模块，函数等等，但它不会列出内置函数和变量的命名。内置函数和变量被定义在builtins模块中，使用dir(builtins)可以返回所有内置函数和变量的名字。  </p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>　　包是通过使用“点号模块名”来构造Python的模块名称空间的一种方式。例如，模块名A.B就是包在命名为A中的B模块。就像使用不同模块的中的相同名字不必担心彼此的全局变量名称一样,点号模块名称也使得使用者不必担心不同包如NumPy或Python的图像库中相同的模块产生混淆。<br>　　想象一下，如果你想设计一个统一处理声音文件和声音数据的模块集合（包）。声音文件有很多种格式（一般以不同的扩展名区分，比如.wav,.aiff），因此你需要不断更新和增加模块去维持各文件格式之间的转换。声音数据也可能需要很多种不同的操作（比如混音，增加回响，提供平衡器功能，创建人工音响效果），因此你将会编写一个无尽头的模块库去实现这些操作。下面是你所涉及的包可能呈现的结构方式：  </p><pre><code>sound/                          Top-level package    __init__.py               Initialize the sound package    formats/                  Subpackage for file format conversions          __init__.py          wavread.py          wavwrite.py          aiffread.py          aiffwrite.py          auread.py          auwrite.py          ...     effects/                  Subpackage for sound effects          __init__.py          echo.py          surround.py          reverse.py          ...     filters/                  Subpackage for filters          __init__.py          equalizer.py          vocoder.py          karaoke.py          ...</code></pre><p>　　当导入这个包时，Python会在sys.path定义的路径中查找包的子文件夹。<br>　　__init__.py使Python将文件夹当做封闭包结构；这种做法防止了在后面查询模块名时，无意中包名和模块名相同时的冲突。最简单的情况下，__init__.py可以只是一个空文件，当然它也可以执行包的初始化代码或者设置__all__变量。<br>　　用户可以从包中导入自己定义的模块，比如：  </p><pre><code>import sound.effects.echo </code></pre><p> 　　这会载入sound.effects.echo子模块。但使用模块中的函数时，一定要使用全名：  </p><pre><code>sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)    </code></pre><p>　　 另一种导入子模块的方法是：  </p><pre><code>from sound.effects import echo </code></pre><p>　　 这也会载入echo子模块，但使用模块中的函数时，它可以不需要包名作为前缀：  </p><pre><code>echo.echofilter(input, output, delay=0.7, atten=4)  </code></pre><p>　　<br>    当然也可以直接导入函数或变量：  </p><pre><code>from sound.effects.echo import echofilter  </code></pre><p>　　　使用这种方法加载echo子模块，那么可以直接使用它的函数：  </p><pre><code>echofilter(input,output,delay=0.7,atten=4)  </code></pre><p>　　 当使用from package import item的形式，item可以是包中的一个子模块，也可以是包中其他任意的名字（像类名、函数名、变量名等）。import声明首先会检测item是否被定义在包内，如果不是，它会假设item是一个模块并试图加载它。如果在包中没有找到item，就会报出ImportError异常。　　<br>　　相反，当使用像import item.subitem.subsubitem的形式，除了最后一个item可以不是包，其他都必须是包名；最后一个item可以是一个模块或包但不可以是前面一个item中定义的类、函数或变量。  </p><h3 id="从包中import"><a href="#从包中import" class="headerlink" title="从包中import *"></a>从包中import *</h3><p>　　当使用form sound.effects import <em>会发生什么？理想情况下，用户可能希望这种方法可以以某种方法进入文件系统，找出包中的子模块，并将它们全部导入。这可能会花费很长时间而且导入子模块会产生意想不到的副作用（当然只有在子模块被显式导入时，这种副作用才会产生）。<br>　　唯一解决的方法是包的作者提供包的显式目录。import的声明会使用下列约束：如果包中__init__.py代码定义了一个名为__all__的列表时，那这个列表将会被作为from package import </em>导入的模块名列表。它要求包的作者在包版本更新时也及时更新该列表。比如：sound/effects/__init__.py中可以包含如下代码：  </p><pre><code>__all__=[&apos;echo&apos;,&apos;surround&apos;,&apos;reverse&apos;] </code></pre><p>　　这意味着from sound.effects import <em>将会从包中加载这三个子模块。<br>　　如果没有定义__all__，from sound.effects import </em>声明不会将sound.effects包中的任意子模块名导入到当前的命名空间；它只会在确定sound.effects包名已经被导入后再导入包中定义的名称。这些名称包含__init__.py中定义的任意名称和任意在前面已经通过import声明显式导入的包中的子模块名。考虑下列代码：  </p><pre><code>import sound.effects.echoimport sound.effects.surroundfrom sound.effects import *</code></pre><p>　　这个例子中，当执行from……import声明时，echo和surround模块也会被导入到当前命名空间，因为它们已经被显式导入。<br>　　虽然当使用import *时，特定的模块被设计成遵循特定的方式只输出名称，但在生产代码时，这还是被认为糟糕的做法。<br>　　使用from Package import specific_submodule的方式将永远是正确的。实际上，这是推荐的表示方法，除非需要导入模块来自不同包的同名子模块。  </p><h1 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h1><p>　　程序的输出可以有多种呈现方式，数据可以打印成可读方式 ，或者写入一个文件供以后使用。这章将会探讨可能的输出方式。 　　</p><h2 id="设计输出格式"><a href="#设计输出格式" class="headerlink" title="设计输出格式"></a>设计输出格式</h2><p>　  　到目前为止，我们遇到了两种写值的方式：表达式语句和print（）函数。（第三种方法是使用文件对象的write()方法；标准输出文件可以被引用为sys.stdout。）<br>　　经常你会希望更多方式的控制输出的格式，而不是仅仅打印用空格分开的值。有两种方法去格式化你的输出；第一种方法是所有的字符串自己处理；使用字符串切片和连接操作，你可以创建任何你可以想到的布局。字符串类型有一些方法可以很好的将字符串填入一个给定列宽度的空间。第二种方法是是使用格式化的字符串，或者能够使用str.format()的方法。<br>　　字符串模块包含一个模板类，这个类提供另一种把值转换成字符串的方法。<br>　　那如何把其他类型值转换成字符串呢？Python中可以通过repr()或者str()函数将它转换成字符串。<br>　　str（）函数的目的是返回可读的值，但是repr()函数的目的是返回解释器可以读懂的值。许多类型像数字或结构像列表和字典的值，使用repr()和str()函数，返回的值是一样的。特殊情况是字符串，两个函数转换字符串返回的值有所不同。  </p><pre><code>&gt;&gt;&gt; s = &apos;Hello, world.&apos;&gt;&gt;&gt; str(s)&apos;Hello, world.&apos;&gt;&gt;&gt; repr(s)&quot;&apos;Hello, world.&apos;&quot;&gt;&gt;&gt; str(1/7)&apos;0.14285714285714285&apos;&gt;&gt;&gt; x = 10 * 3.25&gt;&gt;&gt; y = 200 * 200&gt;&gt;&gt; s = &apos;The value of x is &apos; + repr(x) + &apos;, and y is &apos; + repr(y) + &apos;...&apos;&gt;&gt;&gt; print(s)The value of x is 32.5, and y is 40000...&gt;&gt;&gt; # The repr() of a string adds string quotes and backslashes:... hello = &apos;hello, world\n&apos;&gt;&gt;&gt; hellos = repr(hello)&gt;&gt;&gt; print(hellos)&apos;hello, world\n&apos;&gt;&gt;&gt; # The argument to repr() may be any Python object:... repr((x, y, (&apos;spam&apos;, &apos;eggs&apos;)))&quot;(32.5, 40000, (&apos;spam&apos;, &apos;eggs&apos;))&quot;　　</code></pre><p>　　下面是打印数字平方和立方阵列的两种方法：  </p><pre><code>&gt;&gt;&gt; for x in range(1, 11):...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=&apos; &apos;)...     # Note use of &apos;end&apos; on previous line...     print(repr(x*x*x).rjust(4))...1   1    12   4    83   9   274  16   645  25  1256  36  2167  49  3438  64  5129  81  72910 100 1000  &gt;&gt;&gt; for x in range(1, 11):...     print(&apos;{0:2d} {1:3d} {2:4d}&apos;.format(x, x*x, x*x*x))...1   1    12   4    83   9   274  16   645  25  1256  36  2167  49  3438  64  5129  81  72910 100 1000  </code></pre><p>　　输出格式的排版，第一个例子使用了str.rjust()函数，即字符串右对齐。还有其他几个相似的函数如str.ljust()(左对齐)、str.center()(居中)。这些函数都不会写入任何东西，只是返回一个新的字符串。如果输入的字符串太长，它们也不会截断字符串，而是直接不加改变返回原字符串。如果想截断字符串可以加一个切片操作，如in x.ljust(n)[:n]。　　<br>　　还有另外一个函数str.fill()，它可以在数字型字符串左边添加0.它可以理解加法和减法运算符：  </p><pre><code>&gt;&gt;&gt; &apos;12&apos;.zfill(5)&apos;00012&apos;&gt;&gt;&gt; &apos;-3.14&apos;.zfill(7)&apos;-003.14&apos;&gt;&gt;&gt; &apos;3.14159265359&apos;.zfill(5)&apos;3.14159265359&apos;  </code></pre><p>　　str.format()函数的基本用法如下：  </p><pre><code>&gt;&gt;&gt;    print(&apos;Who is the {} who say &quot;{}!&quot;&apos;.format(&apos;boy&apos;,&apos;Wonderful&apos;))Who    is the boy who say &quot;Wonderful!&quot;  </code></pre><p>　　花括号以及括号内的字符（被称为格式域）被str.format()函数传递的对象所取代。花括号中的数值可以用作str.format()函数对象替代的位置。  </p><pre><code>&gt;&gt;&gt; print(&apos;{0} and {1}&apos;.format(&apos;spam&apos;, &apos;eggs&apos;))spam and eggs&gt;&gt;&gt; print(&apos;{1} and {0}&apos;.format(&apos;spam&apos;, &apos;eggs&apos;))eggs and spam  </code></pre><p>　　如果在str.format()函数中使用关键字参数，它们的值将会被关键字参数对应的值代替。  </p><pre><code>&gt;&gt;&gt; print(&apos;This {food} is {adjective}.&apos;.format(...       food=&apos;spam&apos;, adjective=&apos;absolutely horrible&apos;))   #若在花括号中使用了关键字，而format()函数没有对应的关键字，解释器将会报关键字错误。This spam is absolutely horrible.  </code></pre><p>　　位置和关键字参数可以任意组合。  </p><pre><code>&gt;&gt;&gt; print(&apos;The story of {0}, {1}, and {other}.&apos;.format(&apos;Bill&apos;, &apos;Manfred&apos;,                                               other=&apos;Georg&apos;))The story of Bill, Manfred, and Georg.  </code></pre><p>　　‘!a’(应用于ascii()),’!s’（应用于str()）和’!r’（应用于repr()）可以在格式化之前进行格式转换：  </p><pre><code>&gt;&gt;&gt; contents = &apos;eels&apos;&gt;&gt;&gt; print(&apos;My hovercraft is full of {}.&apos;.format(contents))My hovercraft is full of eels.&gt;&gt;&gt; print(&apos;My hovercraft is full of {!r}.&apos;.format(contents))My hovercraft is full of &apos;eels&apos;.  </code></pre><p>　　一个可选的“：”和格式说明符可以跟随字段名。这允许更全面的控制值的格式。下面是保留Pi小数点后三位数的例子：  </p><pre><code>&gt;&gt;&gt;import math&gt;&gt;&gt;print(&apos;The balue of PI is approximately {0:.3f}.&apos;.format(math.pi))The value of PI is approximately 3.142.  </code></pre><p>　　在’：’后面跟一个数字将会使格式域的长度为最小数字个字符的长度。这可以被用于排版表格。  </p><pre><code>&gt;&gt;&gt;table={&quot;Jack&quot;:123,&quot;Jone&quot;:234}&gt;&gt;&gt;for a,b in table.items():        print(&apos;{0:10} {1:10d}&apos;.format(a,b))Jack              123Jone              234  </code></pre><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>　　%操作可以用于字符串的格式化。比如：  </p><pre><code>&gt;&gt;&gt; import math&gt;&gt;&gt; print(&apos;The value of PI is approximately %5.3f.&apos; % math.pi)The value of PI is approximately 3.142.  </code></pre><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>　　open()函数返回一个文件对象，它通常使用两个参数：open(filename,mode)。  </p><pre><code>&gt;&gt;&gt;f=open(&apos;workfile&apos;,&apos;w&apos;)   </code></pre><p>　　  第一个参数是包含文件名的字符串；第二个参数为读写模式的指代字符。当文件已只读方式打开时，模式可以是’r’；’w’为只写模式（相同名字的已存在的文件将会被擦写掉）;’a’为打开附加模式,任何被写入的数据都会自动添加在文件最后。’r+’同时以读和写两种方式打开文件。模式参数可以缺省，但缺省情况下默认为’r’模式。<br>　　一般情况下，文件是以文本格式打开，也就是，从文件中读写的字符串需要指定编码格式。如果未指定编码格式，默认情况下由运行系统决定。’b’为以二进制模式打开文件；二进制模式可以应用于任何不包含文本格式的文件。<br>　　在文本格式下，当读文件时，默认会地将每行的结尾（在Unix系统中是\n，Window系统中是\r\n）转换为\n。当以文本格式进行写操作时，默认情况下会把换行符\n转换成系统默认的换行符。这种对文件数据的幕后修改对于文本文件来说是没问题的，但是会在像JPEG或EXE的文件中损坏二进制数据。在读写这样的文件时要非常小心使用二进制模式。<br>　　当处理文件系统时，使用with关键字将是一个很好的习惯。这样做的好处是，即使在某个点上出现了异常，文件也会在其操作结束后被正确关闭。使用with也比编写相同的try-finally块要短得多：</p><pre><code>&gt;&gt;&gt; with open(&apos;workfile&apos;) as f:...     read_data = f.read()&gt;&gt;&gt; f.closedTrue  </code></pre><p>　　如果没有使用with关键字，那么就需要调用f.close()函数去关闭文件并立即释放任何被它使用的系统资源。如果不显式地关闭文件，Python的垃圾回收机制将最终会销毁对象并关闭文件，但文件不会立即被关闭，而会持续一段时间。另一个风险是不同的Python任务会在不同的时间清理这些打开的文件。<br>　　当一个文件对象关闭后，无论是使用with关键字还是通过调用f.close()，将无法再使用这个文件对象。  </p><pre><code>&gt;&gt;&gt; f.close()&gt;&gt;&gt; f.read()Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: I/O operation on closed file  </code></pre><h3 id="文件对象的方法"><a href="#文件对象的方法" class="headerlink" title="文件对象的方法"></a>文件对象的方法</h3><p>　　以下例子均设想一个称为f的文件对象已经被建立。<br>　　读取文件内容，调用f.read(size),这个函数读取一些数据并将它们返回成字符（在文本模式下）或二进制对象（在二进制模式下），size是一个可选参数。当size缺省或为负数时，文件中的整个内容将会会被读取和返回。如果文件的结尾已经到达了，f.read()将会返回一个空的字符串（’’）。  </p><pre><code>&gt;&gt;&gt; f.read()&apos;This is the entire file.\n&apos;&gt;&gt;&gt; f.read()&apos;&apos;  </code></pre><p>　　f.readline()读取文件中的单独一行； 新行的换行字符会留在字符串的末尾，而且只有文件的最后一行会缺省换行字符（如果文件没有以换行符结束）。这使得函数返回的值清晰明确；如果f.readline()返回一个空字符串，说明读取到文件的结尾，当一个空行由’\n’表示时，一个字符串只包含一行。  </p><pre><code>&gt;&gt;&gt; f.readline()&apos;This is the first line of the file.\n&apos;&gt;&gt;&gt; f.readline()&apos;Second line of the file\n&apos;&gt;&gt;&gt; f.readline()&apos;&apos;  </code></pre><p>　　<br>　　对于一行一行的从文件中读取，可以对整个文件对象进行循环操作。这种操作节省内存、快，而且代码简洁：  </p><pre><code>&gt;&gt;&gt; for line in f:...     print(line, end=&apos;&apos;)...This is the first line of the file.Second line of the file  </code></pre><p>　　如果想要读取文件中所有的行，也可以使用list(f)或者f.readlines()。<br>　　f.write(string)将字符串写入文件，函数返回写入字符的个数。</p><pre><code>&gt;&gt;&gt; f.write(&apos;This is a test\n&apos;)15  </code></pre><p>　　其他格式的对象需要先经过转换－转换成字符串（文本模式）或者二进制对象（二进制模式）：　　</p><pre><code>&gt;&gt;&gt; value = (&apos;the answer&apos;, 42)&gt;&gt;&gt; s = str(value)  # convert the tuple to string&gt;&gt;&gt; f.write(s)18  </code></pre><p>　　f.tell()返回文件中当前操作的位置，这个位置用开始位置到当前位置字节数或字符数表示。<br>　　可以使用f.seek(offset，from_what)函数改变文件当前操作的位置，from_waht只能取0,1或者2，0表示离文件开头处offset的位置，1表示离当前位置offset的位置，2表示离文件结尾offset的位置。  </p><pre><code>&gt;&gt;&gt; f = open(&apos;workfile&apos;, &apos;rb+&apos;)&gt;&gt;&gt; f.write(b&apos;0123456789abcdef&apos;)16&gt;&gt;&gt; f.seek(5)      # Go to the 6th byte in the file5&gt;&gt;&gt; f.read(1)b&apos;5&apos;&gt;&gt;&gt; f.seek(-3, 2)  # Go to the 3rd byte before the end13&gt;&gt;&gt; f.read(1)b&apos;d&apos;</code></pre><p>　　在文本文件中（以文本模式打开的文件），只会相对文件起始位置进行查找（例外是可以使用seek(0,2)定位文件结尾处）并且offset只能是f.tell（）可返回的值，或者为0.其他任何offset值都会产生非定义的行为。  </p><h3 id="用json格式存储"><a href="#用json格式存储" class="headerlink" title="用json格式存储"></a>用json格式存储</h3><p>　　字符串可以很容易地被写入或从文件中读取。读取数字需要一点额外的工作才能完成，因为read()方法只能返回字符串。当希望保存像嵌套列表或字典这种复杂的类型时，手动解析和格式化会变得异常复杂。<br>　　与其频繁地写代码和改代码去保存复杂的数据格式，不如使用流行的数据格式json,Python允许json格式和其他格式之间的相互转换。标准的模块被称为json，模块可以提取Python数据层级，并将它们转化为字符串；这个过程称为序列化。在序列化和街序列化之间，表示对象的字符串可以被存储在一个文件或数据中，或通过网络连接发送到远程主机上。  </p><pre><code>&gt;&gt;&gt; import json&gt;&gt;&gt; json.dumps([1, &apos;simple&apos;, &apos;list&apos;])  #数据json化&apos;[1, &quot;simple&quot;, &quot;list&quot;]&apos;   </code></pre><p>   另一个函数dump()，只会岁文本文件进行序列化。因此如果f是一个将要被写入数据的文本文件对象，可以如下操作：  </p><pre><code>json.dump(x,f)  #x为json格式数据，将x写入文件对象。  </code></pre><p>　　<br>　解析对象，若f是一个已经打开的文本文件对象，可以使用load()函数：  </p><pre><code>x = json.load(f)  </code></pre><p>　　 这些简单的序列化技术可以解决列表和字典数据类型的序列化问题，但对于其他随意的类实体，序列化还需要另外的操作。json模块说明文档有相关说明。</p><h1 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h1><p> 　　有两种错误：语法错误和异常。　　</p><h2 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h2><p>　　语法错误，也即语句分析错误，可能是在Python学习过程中最常见的错误：  </p><pre><code>&gt;&gt;&gt; while True print(&apos;Hello world&apos;)  #缺少：File &quot;&lt;stdin&gt;&quot;, line 1while True print(&apos;Hello world&apos;)           ^SyntaxError: invalid syntax  </code></pre><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>　　即使是句法声明和表达在句法构成上是完全正确的，在语句执行时还是可能出现错误。在执行过程中检测到的错误称为异常，异常不是无条件的错误。大多数异常并不是通过程序去解决，相反，是在运行结果中展示错误消息：　　</p><pre><code>&gt;&gt;&gt; 10 * (1/0)Traceback (most recent call last):　File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ZeroDivisionError: division by zero&gt;&gt;&gt; 4 + spam*3Traceback (most recent call last):　File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &apos;spam&apos; is not defined&gt;&gt;&gt; &apos;2&apos; + 2Traceback (most recent call last):　File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: Can&apos;t convert &apos;int&apos; object to str implicitly   </code></pre><p>   错误提示最后一行说明了发生了什么异常。异常有不同的种类，上述例子中的异常分别是ZeroDivisionError、NameError和TypeError。作为异常类型打印出来的字符串是发生的内置异常的名称。这对于所有内置的异常都是适用的，但是对于用户定义的异常（尽管它经常是很有用的）并不适用。标准异常名称是内置标识符（不保留关键字）。<br>　　这一行的其余部分根据异常的类型和原因提供更详细的信息。<br>　　错误消息的前面部分以堆栈回溯的形式显示了异常发生的上下文。一般来说，它包括一个堆栈回溯列出的源代码行；但是，它不会显示标准输入读取的行。  </p><h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2><p>　　可以编写程序去处理特定的异常。请看下面的示例，它向用户询问输入，直到输入一个有效的整数，但允许用户中断程序(使用Control-C或任何操作系统支持的中断方式)；注意，用户生成的中断是通过KeyboardInterrupt异常来实现的。  </p><pre><code>&gt;&gt;&gt;while True:        try:            x=int(input(&quot;Please input an number:&quot;))              break        except ValueError:            print(&quot;Oops! That was no valid number.Try again...&quot;)  </code></pre><p>　　try声明的工作方式如下：  </p><p>　　1. 首先，在try关键字和except关键字try语句会被执行；<br>　　2. 如果没有发生异常，except语句会被跳过不执行而且try语句执行结束；<br>　　3. 如果try语句执行过程中出现异常，剩下的语句会被跳过执行。如果发生的异常与except关键字后的异常类型匹配，except语句会被执行，然后又回到try语句重新执行；<br>　　4.如果发生的异常与except语句中命名的异常不匹配，则将其传递到外部try语句;如果没有找到处理程序，它就是一个未处理的异常，语句执行停止，并像上面那样显示异常消息。<br>　　一个try声明可以有两个或更多except语句去处理不同的异常。一种情况下，最多只有一个异常处理语句被执行。处理程序只处理在相应的try子句中出现的异常，而不是在相同的try语句的其他处理程序中。一个except语句将多个异常用一个tuple类型进行命名，例如:  </p><pre><code>except (RuntimeError, TypeError, NameError):    pass  </code></pre><p>　　如果一个类是相同的类或一个基类(但不是另一种方式)，那么在except语句中的类是可以兼容的(但另一种方式——派生类与基类不兼容)。例如，以下代码将以该顺序打印B、C、D:  </p><pre><code>class B(Exception):    passclass C(B):    passclass D(C):    passfor cls in [B, C, D]:    try:        raise cls()    except D:        print(&quot;D&quot;)    except C:        print(&quot;C&quot;)    except B:        print(&quot;B&quot;)  </code></pre><p>　　<br>　　请注意，如果except语句顺序调转(将except B放在最前面)，它将会打印B、B、B。<br>　　最后一个except语句可以省略异常名称，作为其他所有异常处理的方法。使用这个要非常小心，因为这样很容易掩盖真正的编程错误。它还可以用于打印错误消息，然后重新引发异常(允许调用方处理异常):  </p><pre><code>import systry:    f = open(&apos;myfile.txt&apos;)    s = f.readline()    i = int(s.strip())except OSError as err:    print(&quot;OS error: {0}&quot;.format(err))except ValueError:    print(&quot;Could not convert data to an integer.&quot;)except:    print(&quot;Unexpected error:&quot;, sys.exc_info()[0])    raise   </code></pre><p>　　try…except语句之外可以有else语句，当它出现时，必须是跟在except语句之后。else语句对try子句未引发异常时而必须需要执行的代码非常有用。例如:  </p><pre><code>for arg in sys.argv[1:]:    try:            f = open(arg, &apos;r&apos;)    except OSError:         print(&apos;cannot open&apos;, arg)    else:         print(arg, &apos;has&apos;, len(f.readlines()), &apos;lines&apos;)         f.close()  </code></pre><p>　　使用else语句要比在try子句中添加额外的代码好，因为它避免了意外地捕获由try…except语句保护的代码所引发的异常。<br>　　当异常发生时，它可能具有相关的值，也称为异常的参数。参数的存在和类型取决于异常类型。<br>　　except语句可以在异常名之后指定一个变量。该变量被绑定到一个异常实例，其参数存储在instance.args中。为了方便起见，定义<strong>str</strong>(用来直接直接打印异常实例的参数，而不必引用.args。也可以先实例化一个异常，然后再抛出异常，并根据需要添加任何属性。  </p><pre><code>try:    raise Exception(&apos;spam&apos;, &apos;eggs&apos;)except Exception as inst:    print(type(inst))    # the exception instance    print(inst.args)     # arguments stored in .args    print(inst)          # __str__ allows args to be printed directly,                 # but may be overridden in exception subclasses    x, y = inst.args     # unpack args    print(&apos;x =&apos;, x)    print(&apos;y =&apos;, y)  </code></pre><p>　　如果异常有争议，则将其打印为提示消息的最后一部分(‘ detail ‘)作为未处理异常。<br>　　<br>异常处理程序不只是处理在try子句中出现的异常，也可以处理在try子句中被调用的函数(甚至是间接的)出现的异常。例如:　　</p><pre><code>def this_fails():    x = 1/0try:    this_fails()except ZeroDivisionError as err:    print(&apos;Handling run-time error:&apos;, err)  </code></pre><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>　　 raise声明允许程序强制发生特定异常。例如：  </p><pre><code>&gt;&gt;&gt;raise NameError(&apos;HiThere&apos;)   Traceback (most recent call last):     File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;   NameError: HiThere   </code></pre><p>　　 唯一的参数对抛出的异常进行解释说明。为了抛出异常，raise后面必须是一个异常实体或者异常类（Exception的派生类）。如果传递了异常类，则不使用实参调用它的构造函数来隐式实例化。  </p><pre><code>raise ValueError  # shorthand for &apos;raise ValueError()&apos;  </code></pre><p>　　如果需要决定异常是否被抛出而不打算处理异常，下面例子提供了一个重新抛出异常的方式：  </p><pre><code>&gt;&gt;&gt; try:...     raise NameError(&apos;HiThere&apos;)... except NameError:...     print(&apos;An exception flew by!&apos;)...     raise...An exception flew by!Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;NameError: HiThere  </code></pre><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常  　　"></a>自定义异常  　　</h2><p>　　程序可以通过穿件新的异常类来命名它们自己的异常。但这些异常必须直接或间接派生自Excepttion类。<br>　　任何其他类可以完成的工作，异常类也可以实现，但它们一般会被定义的很简单，一般只提供一些供处理程序解析错误信息的属性。当创建一个可以抛出几个不同错误的模块时，一般的做法是在模块中创建一个异常的基类，然后创建几个子类分别对应一个特定的异常抛出条件：  </p><pre><code>class Error(Exception):    &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;    passclass InputError(Error):    &quot;&quot;&quot;Exception raised for errors in the input.    Attributes:        expression -- input expression in which the error occurred           message -- explanation of the error    &quot;&quot;&quot;    def __init__(self, expression, message):        self.expression = expression        self.message = messageclass TransitionError(Error):    &quot;&quot;&quot;Raised when an operation attempts a state transition that&apos;s not allowed.    Attributes:        previous -- state at beginning of transition        next -- attempted new state        message -- explanation of why the specific transition is not allowed    &quot;&quot;&quot;    def __init__(self, previous, next, message):        self.previous = previous        self.next = next        self.message = message  </code></pre><p>　　大多数异常定义的名字会以“Error”结尾，这与标准异常的命名方式相似。<br>　　许多标准模块一般会定义自己异常去处理函数定义过程中可能发生的错误。  </p><h2 id="定义异常清理动作"><a href="#定义异常清理动作" class="headerlink" title="定义异常清理动作"></a>定义异常清理动作</h2><p>　　try声明有另一个可选的语句，这个语句被用来定义在任何条件都可以执行的清理动作。比如：  </p><pre><code>&gt;&gt;&gt; try:...     raise KeyboardInterrupt... finally:...     print(&apos;Goodbye, world!&apos;)...Goodbye, world!KeyboardInterruptTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;  </code></pre><p>　　finally语句总是在离开try声明之前被执行，无论异常是否发生。当在运行try语句时发生了异常而异常又没被except语句处理，那么异常将会在finally语句运行之后再次被抛出。finally语句在即使try语句被break，continue或return跳出时，还是会被执行。例子如下 ；  </p><pre><code>&gt;&gt;&gt; def divide(x, y):...     try:...         result = x / y...     except ZeroDivisionError:...         print(&quot;division by zero!&quot;)...     else:...         print(&quot;result is&quot;, result)...     finally:...         print(&quot;executing finally clause&quot;)...&gt;&gt;&gt; divide(2, 1)result is 2.0executing finally clause&gt;&gt;&gt; divide(2, 0)division by zero!executing finally clause&gt;&gt;&gt; divide(&quot;2&quot;, &quot;1&quot;)executing finally clauseTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;  File &quot;&lt;stdin&gt;&quot;, line 3, in divideTypeError: unsupported operand type(s) for /: &apos;str&apos; and &apos;str&apos;  </code></pre><p>　正如所见，finally语句在任何情况下都会被执行。TypeError因除数是两个字符串而被抛出，但异常未被except语句处理，因此在finally语句执行之后，异常被再次抛出。<br>　在实际的应用程序中，finally语句一般被用于释放内部资源（像文件、网络连接之类的），而无需关注这些资源是否被成功使用。  </p><h2 id="预定义清理动作"><a href="#预定义清理动作" class="headerlink" title="预定义清理动作"></a>预定义清理动作</h2><p>　　一些对象会定义一些标准的清理动作，当对象不再被需要，而不管这些对象是否被使用成功还是失败时，就会清理对象。请看下面的示例，它试图打开一个文件并将其内容打印到屏幕上。  </p><pre><code>for line in open(&quot;myfile.txt&quot;):    print(line, end=&quot;&quot;)  </code></pre><p>　　这个代码的问题在于，在代码的这一部分已经完成之后，它会让文件打开一段不确定的时间。在简单脚本中，这可能不是个问题，但对于更大的应用程序来说可能是个大问题。with语句允许像文件这样的对象以某种方式使用，以确保它们总是快速而正确地被清理。　　</p><pre><code>with open(&quot;myfile.txt&quot;) as f:    for line in f:        print(line, end=&quot;&quot;)　　</code></pre><p>　　在with语句运行完毕之后，即使在程序执行过程中遇到问题，f文件总是会被正确关闭。  </p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>　　 类将一系列数据和函数方法捆绑在一起。创建一个新的类也就是创建一种新的对象，它允许创建这种类型的实体。每个类实例都可以有保持其自身状态的附加属性。类实体也可以有改变自身状态的函数方法。<br>　　与其他编程语言相比，Python的类机制赋予类少量的新语法和句法。这种机制是C++和Modula-3语言中类的混合。Python中的类提供所有标准面向对象编程：类继承机制允许多个基类，派生类可以重载它的基类的任何函数，并且函数可以调用基类中相同名字的函数。类对象可以包含任意数目、任意种类的数据。与模块一样，类也包含Python的动态性质：它们是在运行时创建的，并且可以在创建后进一步修改。<br>　　在C++中，实现动态性，类成员一般是public类型，并且所有的成员函数是虚函数。像在Smalltalk语言中，类本身就是对象，这就提供了类导入和重命名的语义。不像C++语言和Modula-3语言，Python内置类型可以被用作其他用户扩充功能的基类。同样，像C++中一样，大多数内置的具有特殊语法的操作符（运算操作符，下标操作符等）可以在类实体中重新定义。   </p><h2 id="名称和对象"><a href="#名称和对象" class="headerlink" title="名称和对象"></a>名称和对象</h2><p>　　对象具有唯一性，而多个名称可以绑定到同一个对象。在其他语言中这被称为混叠。在Python中，这种做法并不推荐，并且当处理基本非变类型时，混叠会被安全地忽略掉。当然，混叠在像列表、字典这种可变类型编程时可能会有特殊的作用。因为混叠在某种程度上很像指针。比如，传递一个对象的花销很少因为执行时实际传递的只是一个指针；并且如果一个函数通过参数传递更改一个对象，调用将会不需要像Pascal语言中那样由两个不同参数传递的机制。  </p><h2 id="Python作用域和命名空间"><a href="#Python作用域和命名空间" class="headerlink" title="Python作用域和命名空间"></a>Python作用域和命名空间</h2><p>　　在介绍类之前，先说说一些关于Python作用域的规定。类的定义可以看做是使用命名空间玩出的一些巧妙的技巧，并且您需要知道范围和名称空间如何工作才能完全理解发生了什么。<br>　　命名空间是从名称到对象的映射。大多数名称空间目前都是作为Python字典实现的，但这一点一般不是很明显，而且这种实现方法在以后有可能会改变。命名空间的例子：内置名称的集合（包括像abs()的函数和内置异常名称）；模块中的全局名；以及函数调用中的本地名称。在某种意义上对象的属性集合也形成了一个命名空间。关于命名空间最重要的时在不同命名空间中的名称是绝对的无关联的；比如，用户可以在两个不同的模块定义一个都叫做maximize的函数，使用时通过添加模块名前缀就可以将两个函数区分。<br>　　对象的属性可能是只读或可写的。在下面的例子中，对象属性是可能被重新设置的。模块属性可重写：可以设置 modname.the_answer=42.可写属性也可以通过del语句进行删除。比如，del modname.the_answer将会从对象中移除the<em>answer属性。<br>　　命名空间会在不同时候被创造并拥有不同的生命周期。当Python解释器开始运行时包含内置名称的命名空间开始被创建，且不可删除。模块中的全局命名空间在模块的定义被读取时创建；一般情况下，模块的命名空间的生命周期会持续到解释器退出之时。 解释器的顶层调用所执行的语句，要么从脚本文件中读取，要么是交互式的，被认为是称为\</em>_main__的模块的一部分，因此它们有自己的全局名称空间。(内置的名字也存在一个模块中，这个模块被称为builtins)<br>　　函数的本地命名空间在函数被调用时创建，并且在函数返回或抛出一个围在函数内部处理的异常时被销毁。当然，递归调用的每次调用都有他们自己的本地命名空间。<br>　　Python的命名空间是一个可以直接进入的文本区域。所谓直接进入已实施命名空间可以通过无限制的引用去在命名空间中找到特定的名称。<br>　　尽管作用域是静态确定的，但它们是动态使用的。在执行的任何时期，在能直接进入的命名空间至少有三个嵌套作用域。<br>1.最内层的作用域，执行时会最先被检索，包含本地命名；<br>2.函数内部的作用域，不包含本地命名和全局命名；<br>3.次外层作用域包含当前模块的全局命名；<br>4.最外层作用域（最后被检索）是包含内置名称的命名空间。<br>　　如果一个名字被声明为全局，那么所有的引用和赋值都直接指向包含模块全局名称的中间范围。重新绑定最内层作用域外部的变量，nonlocal声明可能会被用到，如果不声明非本地性，那些变量将会为只读格式（任何试图去重写该参数的做法都将只是简单地在最内层作用域中重新创建一个新的本地变量，而在最内层作用外部的变量没有变化）。<br>　　一般地，本地作用域引用（文本）当前函数的本地名称。在函数外部，本地作用域引用相同的命名空间作为全局作用域：模块的命名空间。类定义在局部范围内放置另一个名称空间。<br>　　理解作用域的原文定义很重要：定义在模块中一个函数的全局作用域就是那个模块的命名空间，无论这个函数的在那或被什么换成其他别名。另一方面，名称的检索是动态处理的，在执行时-然而，语言的定义倾向于静态命名的方案，因此在编译时，不依赖动态命名的方案。（实际上，局部变量已经静态的定义了）<br>　　 Python一个特用的习惯是：如果没有全局声明，那么对名称的分配总是会进入到最内层的作用域。名称的分配不会拷贝数据-它们只是将名称绑定到对象。同样对于名称的销毁：del x的声明删除的是由局部作用域对x的绑定引用。事实上，所有引入新名称的操作都会用到局部作用域：特别地，import声明以及函数定义绑定模块或局部作用域中的函数名称。<br>　　全局声明用于说明特定在全局作用域中的变量并且只能被限制在全局作用域的变量；nonlocal声明说明局部作用域中的变量并且只能被限制在局部作用域中。</p><h3 id="作用域及命名空间实例"><a href="#作用域及命名空间实例" class="headerlink" title="作用域及命名空间实例"></a>作用域及命名空间实例</h3><p>　　下面的例子展示了如何引用不同的作用域和命名空间，以及 global和nonlocal声明如何影响变量的绑定： 　　</p><pre><code>def scope_test():    def do_local():        spam=&quot;local spam&quot;    def do_nonlocal():        nonlocal spam        spam=&quot;nonlocal spam&quot;    def do_global():        global spam        spam=&quot;global spam&quot;    spam=&quot;test spam&quot;    do_local()    print(&quot;After local assignment:&quot;,spam)    do_nonlocal()    print(&quot;After nonlocal assignment:&quot;,spam)    do_global()    print(&quot;After global assignment:&quot;,spam)scope_test()print(&quot;In global scope:&quot;,spam)　　</code></pre><p>  程序的输出如下：　　</p><pre><code>After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spamIn global scope: global spam　　</code></pre><p>  例子中说明local分配(默认为local)并未改变scope_test对spam的绑定。nonlocal声明改变了scope_test对spam的绑定，并且global声明从模块级改变了spam的绑定。  </p><h2 id="初探类"><a href="#初探类" class="headerlink" title="初探类"></a>初探类</h2><p>　　类引入了一些新的语法，三种新的对象类型，以及一些新的语义。  </p><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>　　类最简单的定义形式如下:  </p><pre><code>class ClassName:&lt;statement-1&gt;...&lt;statement-N&gt;  </code></pre><p>　　类定义，如函数定义（def语句）必须在它们有任何效果之前执行。（可能会将雷达额定义放在if条件语句中的一个分支内，或者在一个函数内部。）<br>　　实际上，在类内部的定义将一般是函数的定义，但是其他的声明也是允许的，并且有时候这些其他声明也是有很大用处的。类内部定义的函数一般有一个特别形式的参数列表，这由类方法的调用规则所限定。<br>　　当进入一个类的定义，一个新的命名空间就被创建了，并且被用于局部作用域——因此，所有的局域变量将会分配到这个心新的命名空间。特别地，函数定义在这绑定新的函数名。<br>　　当类定义执行完成，一个类对象被创建。这基本上是由类定义所创建的名称空间内容的包装;我们将在下一节中了解更多关于类对象的知识。原始的局部作用域（在类定义被输入之前生效的）被恢复，类对象被绑定到类定义头中给定的类名（例子中的ClassName）。  </p><h3 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h3><p>　　类对象支持两种操作：属性引用和实例化。<br>　　在python里所有属性引用都采用标准的语法格式：obj.name。合法的属性名称都是在类对象被创建时在类的命名空间的所有名称。因此，如果类的定义如下：  </p><pre><code>class MyClass:    &quot;&quot;&quot;A simple example class&quot;&quot;&quot;    i = 12345    def f(self):        return &apos;hello world&apos;  </code></pre><p>　　那么MyClass.i和MyClass.f就是合法的属性引用，引用返回一个自然数和一个函数对象。类属性也可以被更改。__doc__也是一个合法的属性，返回类中的文档性字符：“A simple example class”。<br>　　类实例化使用函数表述法。假使类对象是一个不带参数返回一个新的类实例的函数。例如：  </p><pre><code>x=MyClass()  </code></pre><p>创建了一个新的类实例并将这个对象赋给局域变量x。<br>　　实例化操作创建了一个空对象。很多情况下最好在创建类对象时将类初始化到一个状态。因此在类的内部可能需要定义一个特殊命名的函数__init__()：  </p><pre><code>def __init__(self):      self.data=[]  </code></pre><p>　　当一个类定义了一个__init__()函数，类实例化时会自动调用__init__()对新建的类进行实例化。因此，在上述例子中，一个已经初始化的类可以用如下方法获得：  </p><pre><code>x=MyClass()  </code></pre><p>　　当然，__init__()函数也可以带其他参数。那样，参数可以通过__init__()传递给类实例化操作符。比如：  </p><pre><code>&gt;&gt;&gt; class Complex:...     def __init__(self, realpart, imagpart):...         self.r = realpart...         self.i = imagpart...&gt;&gt;&gt; x = Complex(3.0, -4.5)&gt;&gt;&gt; x.r, x.i(3.0, -4.5)  </code></pre><h3 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h3><p>　 对实例化对象，能干什么呢？能被实例化对象理解的操作唯有属性引用。有两种形式的合法属性命名，数据属性和方法。<br>　 数据属性对应于Smalltalk语言中的实例变量，对应于C++中的数据成员。数据属性不需要声明;就像局部变量一样，当它们第一次被分配到时，它们就会出现。例如，如果x是MyClass创建的实例，那么下面代码段将会打印出16。  </p><pre><code>x.counter = 1while x.counter &lt; 10:    x.counter = x.counter * 2print(x.counter)del x.counter   </code></pre><p>　　另一种实例属性的引用是method。一个method就是一个对象的函数。（在Python里，method并非类实例所特有的：其他对象格式也可以有methods。比如，list对象有append、insert、remove、sort等method。） 但是，在接下来的讨论中，我们将使用method来表示类实例对象的方法，除非method被显式地声明。）<br>　　实例对象的有效方法名依赖于它的类。根据定义，类的所有函数对象属性都定义了其实例的相应方法。因此在我们的例子中，x.f是个合法的method引用，因为MyClass.f是一个函数，但x.i不是，因为MyClass.i不是。但x.f和MyClass.f并不完全一样——它是method对象，不是函数对象。  </p><h3 id="Method对象"><a href="#Method对象" class="headerlink" title="Method对象"></a>Method对象</h3><p>　　一般情况下，method对象调用时紧跟实例右边：  </p><pre><code>x.f()  </code></pre><p>　　在MyClass例子中，这将会返回‘hello world’字符串。然而，并非一定需要立即调用method：因为x.f是一个method对象，可以存储并在以后调用。例如：  </p><pre><code>xf = x.fwhile True:    print(xf())  </code></pre><p>　该代码片段将会一直打印“hello world”。<br>　　当一个method被调用，到底发生了什么呢？上面的例子中虽然f（）定义了参数，x.f()调用时却是无参数调用。这个参数到底去哪了？当然当一个函数在被调用时需要一个参数而未接收到任何参数即使是这个参数并未被使用时，Python也会直接抛出一个异常。<br>　　实际上，你可能已经猜到答案了：methods的特殊之处是实体对象被当做函数的第一个参数。在例子中，x.f()的调用实际上等价于MyClass.f(x)。一般来说，用n个参数的列表调用一个method等价于通过在第一个参数之前插入方法的实例对象来调用相应的函数。　　<br>  如果仍然不理解method是如何工作的，那么查看method实现过程可能会澄清问题。当一个非数据属性的实例属性被引用时，实例的类将会被查询。如果当查询到属性的名字是类的函数对象属性，那么一个method对象将会通过打包实例对象和函数对象被创建。当method对象通过一个参数列表调用时，一个新的参数列表将会从实例对象和原参数列表中创建，函数对象会以这个新的参数列表调用。  </p><h3 id="类和实例变量"><a href="#类和实例变量" class="headerlink" title="类和实例变量"></a>类和实例变量</h3><p>　　一般来说，实例变量是针对每个实例的唯一的数据，类变量是由类的所有实例共享的属性和方法：  </p><pre><code>class Dog:    kind = &apos;canine&apos;         # class variable shared by all instances    def __init__(self, name):        self.name = name    # instance variable unique to each instance&gt;&gt;&gt; d = Dog(&apos;Fido&apos;)&gt;&gt;&gt; e = Dog(&apos;Buddy&apos;)&gt;&gt;&gt; d.kind                  # shared by all dogs&apos;canine&apos;&gt;&gt;&gt; e.kind                  # shared by all dogs&apos;canine&apos;&gt;&gt;&gt; d.name                  # unique to d&apos;Fido&apos;&gt;&gt;&gt; e.name                  # unique to e&apos;Buddy&apos;  </code></pre><p>　　　　<br>  但像字典和列表可变类型数据作为类的变量是有争议的，因为这样的共享变量会产生意外的结果。像下面例子中tricks变量就被误用。  </p><pre><code>class Dog:    tricks = []             # mistaken use of a class variable    def __init__(self, name):        self.name = name    def add_trick(self, trick):        self.tricks.append(trick)&gt;&gt;&gt; d = Dog(&apos;Fido&apos;)&gt;&gt;&gt; e = Dog(&apos;Buddy&apos;)&gt;&gt;&gt; d.add_trick(&apos;roll over&apos;)&gt;&gt;&gt; e.add_trick(&apos;play dead&apos;)&gt;&gt;&gt; d.tricks                # unexpectedly shared by all dogs[&apos;roll over&apos;, &apos;play dead&apos;]  </code></pre><p>　　正确的用法应该是使用实例变量：　　</p><pre><code>class Dog:    def __init__(self, name):        self.name = name        self.tricks = []    # creates a new empty list for each dog    def add_trick(self, trick):        self.tricks.append(trick)&gt;&gt;&gt; d = Dog(&apos;Fido&apos;)&gt;&gt;&gt; e = Dog(&apos;Buddy&apos;)&gt;&gt;&gt; d.add_trick(&apos;roll over&apos;)&gt;&gt;&gt; e.add_trick(&apos;play dead&apos;)&gt;&gt;&gt; d.tricks[&apos;roll over&apos;]&gt;&gt;&gt; e.tricks[&apos;play dead&apos;]　　</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>　　当然，如果一个类不支持继承属性，那么类就不能称之为类了。继承类的语法定义如下：  </p><pre><code>class DerivedClassName(BaseClassName):    &lt;statement-1&gt;    .    .    .    &lt;statement-N&gt;  </code></pre><p>　　BaseClassName的名称必须被定义在包含衍生类定义的作用域内。除了基类，其他任意表达式也是允许被继承的。这一特性是很有用的，比如，当一个基类被定义在另一个模块的内部：  </p><pre><code>class DerivedClassName(modname.BaseClassName):   </code></pre><p>　　 一个派生类定义的执行与基类的执行是相同的。当一个类对象被创建，基类就被储存了。这主要是为了解决属性引用的问题：如果一个被请求的属性在类中没有找到，那会继续在基类中查找。如果基类本身是从其他类派生出来的，那么这个规则就会被递归地应用。  </p><p>　　衍生类的实例也没什么特别的：DerivedClassName()穿件一个新的类实例。Method引用将会以下面的方式被处理：如果需要的话，沿着基类的链向下查找相关的类属性，如果该属性产生一个函数对象，则该方法引用是有效的。<br>　　衍生类可能会重写它们基类的的methods。因为方法在调用同一个对象的method时优先级是等同的，所以当基类中的method调用同一个基类中的另一个method时，最终可能会调用一个派生类的method来覆盖它。（对于C++程序员来说：Python中所有的method实际上都是虚函数）<br>　　派生类中的method重写实际上可能想要扩展method而不是简单地替换同名的基类method。有一种简单的方法可以直接调用基类method：只需调用BaseClassName.methodname(self,arguments)。（但注意，只有在全局范围内以BaseClassName访问基类时才会起作用。）<br>　　Python有两个内置的关于继承的函数：  </p><ol><li>使用isinstance()去检查实例类型：isinstance(obj,int)在obj.__class__是int或是int的衍生类时返回True;  </li><li><p>使用issubclass()去检查类的继承：issubclass(bool,int)返回True因为bool是int的子类。  </p><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>　　Python同样支持多继承。一个多继承的类定义形式如下：  </p><pre><code>class DerivedClassName(Base1, Base2, Base3):    &lt;statement-1&gt;    .    .    .    &lt;statement-N&gt;  </code></pre><p>　　对于大多数场合，最简单的情况下，查询父类继承的属性，查询顺序的原则是深度优先、从左到右，而不是在层次结构中有重叠的同一类中搜索两次。因此，如果一个属性没有在 DerivedClassName中找到，那么它将在Base1中搜索，然后（递归地）在Base1的基类中搜索，如果没有找到它，那么它就会在Base2中搜索，以此类推。<br>　　事实上，它比上面说的稍微复杂一点。method解析顺序是动态变化的，以支持对super（）的调用。这种方法在其他一些多继承语言中被称为“调用下一个方法”，它比单继承语言中专有调用更强大。<br>　　动态排序是必要的，因为所有多重继承的情况都显示了一个或多个菱形关系（其中至少有一个父类可以通过来自最底类的多个路径访问）。例如，所有的类都继承object，所以任何多重继承的情况都提供了不止一条路径到object。为了阻止多次访问基类，动态算法将搜索顺序线性化，以保持每个类中特定的左右的顺序，只调用基类一次，这是单调的（也就是说一个类可以被子类化而不会影响其基类访问的优先顺序）。综上所述，这些属性使设计具有多重继承的可靠和可扩展的类成为可能。  </p><h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2></li></ol><p>　　在Python中不存在只能在对象内部访问的“私有”实例变量。但是，大多数Python代码有一个约定俗成的规定：带有单下划线前缀的名称（如垃_spam）应该被视为API的非公开部分（无论它是一个函数还是method或数据成员）。它应该被认为是一个实现细节，并且阻止在没有有通知的情况下对这些成员进行更改。<br>　　由于类私有成员有一个有效的用例（即避免名称与子类定义的名称冲突），所以对这种机制的有限支持，称为名称矫正。任何像__spam形式的标识符（至少以两个下划线为名称开头，名称尾部最多一个下划线）会被解释器替换成_classname__spam,classname是当前的类名，带有前导下划线。在类的定义中，无论这种表示符在哪个地方，都会默认进行这样的名称转化处理。<br>　　名称矫正有助于让子类重写method而不破坏同类的method的调用。例如：  </p><pre><code>class Mapping:    def __init__(self, iterable):        self.items_list = []        self.__update(iterable)    def update(self, iterable):        for item in iterable:            self.items_list.append(item)    __update = update   # private copy of original update() methodclass MappingSubclass(Mapping):    def update(self, keys, values):        # provides new signature for update()        # but does not break __init__()        for item in zip(keys, values):            self.items_list.append(item)  </code></pre><p>　　需要注意的是，这些矫正规则的设计主要是为了避免冲突;但仍然可以访问或修改一个被认为是私有的变量。这可能在一些特殊情况下很有用，比如调试器。<br>　　传递给exec（）或eval（）的代码并不会将调用的类名当做当前类;这类似于全局语句的效果，它的效果同样局限于字节编译的代码。同样的限制也适用于getattr（）、setattr（）和delattr（），以及直接引用的__dict__。  </p><h2 id="零零碎碎"><a href="#零零碎碎" class="headerlink" title="零零碎碎"></a>零零碎碎</h2><p>　　有时，有一个类似于Pascal“record”或C“struct”的数据类型是很有用的，它将一些命名的数据项捆绑在一起。一个空的类定义会很好地完成这项工作：　　</p><pre><code>class Employee:    passjohn = Employee()  # Create an empty employee record# Fill the fields of the recordjohn.name = &apos;John Doe&apos;john.dept = &apos;computer lab&apos;john.salary = 1000</code></pre><p>　　一段期望特定抽象数据类型的Python代码通常可以传递一个模拟该数据类型方法的类。例如，如果你有一个函数，它从一个文件对象中格式化一些数据，你可以用方法read（）和readline（）来定义一个类，它从一个字符串缓冲区获取数据，并将其作为参数传递。<br>　　实例方法对象也有属性：m．self是方法m（）创建的实例化对象，m.__func__的实例对象与该方法对应的函数对象。  </p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>　　到目前为止，您可能已经注意到，大多数容器类对象都可以使用for语句进行循环：</p><pre><code>for element in [1, 2, 3]:    print(element)for element in (1, 2, 3):    print(element)for key in {&apos;one&apos;:1, &apos;two&apos;:2}:    print(key)for char in &quot;123&quot;:    print(char)for line in open(&quot;myfile.txt&quot;):    print(line, end=&apos;&apos;)  </code></pre><p>　　这种访问方式清晰、简洁、方便。迭代器的使用遍及并统一了Python。在背后，for语句在容器对象上调用iter（）。这个函数返回一个迭代器对象，它定义了next（）方法，next()函数每次进入容器访问一个元素。当没有更多的元素时，next（）会引发一个停止迭代异常，它告诉for循环终止。可以使用内置函数 next()函数 来调用__next__（）方法;下面的例子展示了它是如何工作的：  </p><pre><code>&gt;&gt;&gt; s = &apos;abc&apos;&gt;&gt;&gt; it = iter(s)&gt;&gt;&gt; it&lt;iterator object at 0x00A1DB50&gt;&gt;&gt;&gt; next(it)&apos;a&apos;&gt;&gt;&gt; next(it)&apos;b&apos;&gt;&gt;&gt; next(it)&apos;c&apos;&gt;&gt;&gt; next(it)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;    next(it)StopIteration  </code></pre><p>　　在看到迭代器协议背后的机制之后，很容易将迭代器行为添加到类中。定义一个__iter（）__方法，该方法用__next__（）方法返回一个对象。如果该类定义了__next__（），那么__iter（）__就可以返回self：  </p><pre><code>class Reverse:    &quot;&quot;&quot;Iterator for looping over a sequence backwards.&quot;&quot;&quot;    def __init__(self, data):        self.data = data        self.index = len(data)    def __iter__(self):        return self    def __next__(self):        if self.index == 0:            raise StopIteration        self.index = self.index - 1        return self.data[self.index]  </code></pre><p>__</p><pre><code>&gt;&gt;&gt; rev = Reverse(&apos;spam&apos;)&gt;&gt;&gt; iter(rev)&lt;__main__.Reverse object at 0x00A1DB50&gt;&gt;&gt;&gt; for char in rev:...     print(char)...maps</code></pre><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>　　生成器是创建迭代器简单而强大的工具。它们的编写方式类似于常规函数，但每当它们想返回数据时，就使用yield语句。每次调用next（）时，生成器会在它中断的地方恢复（它会存储所有的数据值和最后执行的语句）。下面的例子表明，生成器可以很容易地创建：  </p><pre><code>def reverse(data):    for index in range(len(data)-1, -1, -1):        yield data[index]</code></pre><p>—  </p><pre><code>&gt;&gt;&gt; for char in reverse(&apos;golf&apos;):...     print(char)...flog  </code></pre><p>　　任何可以用生成器完成的事情都可以使用基于类的迭代器来完成。使生成器如此简洁的原因是，__iter（）__和__next（）__方法是被自动创建的。<br>　　另一个关键特性是，本地变量和执行状态会在被调用之间自动保存。这使得这个函数更容易编写，而且比使用像self.index和self.data这样的实例变量更加清晰。<br>　　除了自动方法创建和保存程序状态之外，当生成器终止时，它们会自动抛出StopIteration的异常。总的来说，这些特性使得创建迭代器变得比编写一个常规的函数还要容易。  </p><h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>　　一些简单的生成器可以用类似于列表推导的语法来简单地编码。这些表达式是为生成器闭包使用的情况而设计的。生成器表达式比完整的生成器定义更紧凑，但功能要少些，并且比同等的列表推导更好记。<br>　　比如：  </p><pre><code>&gt;&gt;&gt; sum(i*i for i in range(10))                 # sum of squares285&gt;&gt;&gt; xvec = [10, 20, 30]&gt;&gt;&gt; yvec = [7, 5, 3]&gt;&gt;&gt; sum(x*y for x,y in zip(xvec, yvec))         # dot product260&gt;&gt;&gt; from math import pi, sin&gt;&gt;&gt; sine_table = {x: sin(x*pi/180) for x in range(0, 91)}&gt;&gt;&gt; unique_words = set(word  for line in page  for word in line.split())&gt;&gt;&gt; valedictorian = max((student.gpa, student.name) for student in graduates)&gt;&gt;&gt; data = &apos;golf&apos;&gt;&gt;&gt; list(data[i] for i in range(len(data)-1, -1, -1))[&apos;f&apos;, &apos;l&apos;, &apos;o&apos;, &apos;g&apos;]</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说明：该教程翻译自Python官网教程，该教程为python的语法基础，不包含Python流行库的介绍，需要查看英文原文，请点击&lt;a href=&quot;https://docs.python.org/3/tutorial/index.html&quot;&gt;https://docs.python.org/3/tutorial/index.html&lt;/a&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://focusok.xyz/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Python" scheme="http://focusok.xyz/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+github建站配置</title>
    <link href="http://focusok.xyz/2017/02/26/myfirstblog/"/>
    <id>http://focusok.xyz/2017/02/26/myfirstblog/</id>
    <published>2017-02-26T10:30:19.000Z</published>
    <updated>2018-01-07T12:20:40.461Z</updated>
    
    <content type="html"><![CDATA[<p><center></center></p><h1 id="Hexo-Github建站"><a href="#Hexo-Github建站" class="headerlink" title="Hexo+Github建站"></a>Hexo+Github建站</h1><h3 id="使用hexo和Gitpage建站配置"><a href="#使用hexo和Gitpage建站配置" class="headerlink" title="使用hexo和Gitpage建站配置"></a>使用hexo和Gitpage建站配置</h3><p>　　第一次使用hexo和GitPage建立自己的个人博客。如何用hexogithub创建自己的个人博客，这个自不必多说，网上有很多教程，参照教程就可以很简单将网站搭建起来，当然在这推荐<a href="http://www.cnblogs.com/MuYunyun/p/5927491.html" target="_blank" rel="external">http://www.cnblogs.com/MuYunyun/p/5927491.html</a>,这个教程讲的不能再详细了。当然遇到hexo上的问题，可以参考<a href="https://hexo.io/docs/" target="_blank" rel="external">hexo官网文档</a>，讲的也简单易懂。<a id="more"></a></p><h3 id="添加多说评论插件"><a href="#添加多说评论插件" class="headerlink" title="添加多说评论插件"></a>添加多说评论插件</h3><p>　　Hexo默认评论插件是Disqus，但Disqus访问较慢，需要注册,比较麻烦，多说可以用微博、qq等登录，无需注册，操作起来很方便.添加多说的步骤可以参考这个教程<a href="http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9" target="_blank" rel="external">http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9</a>.里面要提的是duoshuo_shortname的设置就是第一次登录多说在多说中设置的二级域名除掉.duoshuo.com的部分，比如我当时设置的是<a href="http://focusok.duoshuo.com,那么duoshuo_shortname设置为focusok。" target="_blank" rel="external">http://focusok.duoshuo.com,那么duoshuo_shortname设置为focusok。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;h1 id=&quot;Hexo-Github建站&quot;&gt;&lt;a href=&quot;#Hexo-Github建站&quot; class=&quot;headerlink&quot; title=&quot;Hexo+Github建站&quot;&gt;&lt;/a&gt;Hexo+Github建站&lt;/center&gt;&lt;/h1&gt;&lt;h3 id=&quot;使用hexo和Gitpage建站配置&quot;&gt;&lt;a href=&quot;#使用hexo和Gitpage建站配置&quot; class=&quot;headerlink&quot; title=&quot;使用hexo和Gitpage建站配置&quot;&gt;&lt;/a&gt;使用hexo和Gitpage建站配置&lt;/h3&gt;&lt;p&gt;　　第一次使用hexo和GitPage建立自己的个人博客。如何用hexogithub创建自己的个人博客，这个自不必多说，网上有很多教程，参照教程就可以很简单将网站搭建起来，当然在这推荐&lt;a href=&quot;http://www.cnblogs.com/MuYunyun/p/5927491.html&quot;&gt;http://www.cnblogs.com/MuYunyun/p/5927491.html&lt;/a&gt;,这个教程讲的不能再详细了。当然遇到hexo上的问题，可以参考&lt;a href=&quot;https://hexo.io/docs/&quot;&gt;hexo官网文档&lt;/a&gt;，讲的也简单易懂。
    
    </summary>
    
      <category term="网站" scheme="http://focusok.xyz/categories/%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="配置" scheme="http://focusok.xyz/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
</feed>
